<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring中事务相关</title>
      <link href="/2022/08/24/Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/08/24/Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring中事务相关知识"><a href="#Spring中事务相关知识" class="headerlink" title="Spring中事务相关知识"></a><strong>Spring中事务相关知识</strong></h3><blockquote><ul><li>什么是事务</li><li>4种事务特性</li><li>5种隔离级别</li><li>7种传播行为</li><li>事务的回滚机制</li><li>事务失效场景</li></ul></blockquote><ul><li><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a><strong>什么是事务?</strong></h4><blockquote><p>事务指的是<strong>程序中一组严密的逻辑操作，组成这组操作的各个逻辑单元，要么一起成功，要么一起失败。</strong>通俗来讲，就是把多件事情当作一件事情来处理，就像是在同一条船上的人，要活一起活，要死一起死。</p></blockquote></li></ul><hr><ul><li><h4 id="Spring的4种事务特性是什么"><a href="#Spring的4种事务特性是什么" class="headerlink" title="Spring的4种事务特性是什么?"></a><strong>Spring的4种事务特性是什么?</strong></h4><blockquote><ul><li><p><strong>原子性(Atomicity)：强调事务的不可分割。</strong>整个事务中，所有的操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不存在只执行其中一部分操作。</p></li><li><p><strong>一致性(Consistency)：事务执行的前后数据的完整性必须保持一致。</strong>数据库总是从一个一致性的状态转换为另一个一致性的状态。</p></li><li><p><strong>隔离性(Isolation)：一个事务执行的过程中，不应该受到其他事务的干扰。</strong>当多个用户并发访问数据库时，数据库要为每一个用户开启事务，不能被其他事务的操作所干扰，即<strong>多个并发事务之间要相互隔离。</strong></p><p>要达到这样一种效果：对于任意两个并发的事务A和B，在事务A看来，B要么在A开始之前就已经结束，要么在A结束之后才开始。一个事务在提交之前，对于其他事务来说是不可见的。</p></li><li><p><strong>持久性(durability)：</strong>事务一旦正确提交，它对于数据库的改变是永久的。</p></li></ul></blockquote></li></ul><hr><ul><li><h4 id="Spring中事务的5种隔离级别都是什么？"><a href="#Spring中事务的5种隔离级别都是什么？" class="headerlink" title="Spring中事务的5种隔离级别都是什么？"></a>Spring中事务的5种隔离级别都是什么？</h4><blockquote><p><strong>Spring数据库中事务的隔离级别分为四种(级别递减)：</strong></p><ul><li><p><strong>Serializable (序列化)：</strong>这是数据库<strong>最高的隔离级别，</strong>这种级别下，事务会”序列化执行”，即一个一个排队执行。在这种级别下，”脏读”，”不可重复读”，”幻读”都可以被避免，但代价则是执行效率差，性能开销大。</p></li><li><p><strong>REPEATABLE READ(可重复读)：</strong>保证多次读取同一数据时，其值和事务开始时候的内容一致。<strong>即开始读取数据(事务开启)时，不再允许修改操作。</strong>可以有效避免”不可重复读”，但是无法避免”幻读”，因为幻读是由于插入或者删除操作而产生。</p><p>PS：可重复读就是专门针对”不可重复读”而制定的隔离级别，自然可以有效避免”不可重复读”，而其也是<strong>MySql默认的隔离级别。</strong></p></li><li><p><strong>READ COMMITTED(读已提交)：只能读取到已经提交了的内容。</strong>即一个事务要等到另一个事务提交后，才能读取数据。这是各种系统中最常用的一种隔离级别，也是Oracle的默认隔离级别。其保证了一个事务不会读到另一个并行事务已修改但未提交的数据，能够有效避免”脏读”，但不能避免”幻读”，”不可重复读”。该级别适用于大多数系统。</p></li><li><p><strong>Read Uncommitted(读未提交)：最低的隔离级别，事务未提交前，就可以被其他事务读取。</strong>在这种隔离级别下，查询不会加锁，也正是因为不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”，“不可重复读”，“幻读”。如无特殊情况，基本不会使用这种隔离级别。</p></li><li><p><strong>PS：DEFAULT(默认)：默认隔离级别。</strong>即使用底层数据库设置的隔离级别，数据库使用什么样的隔离级别，就用什么。</p></li></ul><p><strong>脏读，不可重复读，幻读：</strong></p><ul><li><p><strong>脏读：表示一个事务能够读取到另一个事务中还未提交的数据。</strong>即读取到了其他事务回滚前的数据。比如事务B在执行过程中修改了数据x，在未提交前，事务A读取了x，而事务B却回滚了，这样事务A就形成了脏读。也就是说，<strong>当前事务读到的数据是别的事务想要修改但是没有修改成功的数据。</strong></p><p><strong>eg：</strong>老板给员工发工资，员工工资为2.6万&#x2F;月，但是发工资时老板不小心把工资按成了2.9万&#x2F;月，此时工资虽然修改，但是事务还未提交。恰巧此时员工查看本月工资时，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚了事务，将工资改为2.6万后进行了提交。</p></li></ul><hr><p>  实际上员工工资仍然是2.6万&#x2F;月，但是员工看到的是2.6万。他看到的是老板还未提交事务时的数据。这就是脏读。</p><ul><li><p><strong>不可重复读：当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配。</strong>即事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取到的时候，发现数据不匹配了，这就是不可重复读。</p><p><strong>eg：</strong>小明本月发工资后，拿着钱去吃喝玩乐，当他买单的时候(事务开启)，收款机检测到小明银行卡中有本月工资2.6万元，此时，小明女朋友小花突然把其卡中工资全部转出充当家用(修改并提交事务)。当收款机准备扣除金额时，再次检测银行卡中金额，发现已经没钱了。</p></li></ul><hr><p>  一个事务范围内两个相同的查询却返回了不同的数据，这就是不可重复读。</p><ul><li><p><strong>幻读：当前事务读第一次取到的数据比后来读取到的数据条目少。</strong>即事务A首先根据条件索引得到N条数据，然后事务B增添了M条符合事务A搜索条件的数据，导致事务A再次读取发现有N+M条数据。</p><p><strong>eg：</strong>小明某天去买东西，花了2千元买了一部手机，然后他的女朋友小花查看他今天的消费记录(事务开启)，看到了2千元，就在这时小明又花了1万元买了一部电脑，即新增(insert)了一条消费记录并提交。当小花打印出小明的消费记录时(事务提交)，发现花了1.2万元，这就是幻读。</p></li><li><p><strong>不可重复读与幻读：两者相似，前者针对update&#x2F;delete，后者针对insert</strong></p></li><li><p>在设置数据库的隔离级别时一定要在<strong>开启事务之前。</strong></p></li></ul></blockquote></li></ul><hr><ul><li><h4 id="事务的7种传播行为？"><a href="#事务的7种传播行为？" class="headerlink" title="事务的7种传播行为？"></a>事务的7种传播行为？</h4><blockquote><p><strong>事务的传播行为：指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行。</strong>例如，方法A调用方法B时，B是继续在调用者A的事务中运行，还是自己开启一个新的事务运行，这就由B的事务传播行为决定。</p><p>事务的7种传播行为：</p><ul><li><p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。</p></li><li><p>事务传播行为是Spring框架独有的事务增强特性。</p></li></ul><ol><li><p><strong>PROPAGATION_REQUIRED：没有新建，有则加入。</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务。这是最常用的选择，同时也是Spring默认的事务传播行为。</p></li><li><p><strong>PROPAGATION_SUPPORTS：有则加入，没有则以非事务运行。</strong>如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p></li><li><p><strong>PROPAGATION_MANDATORY：有则加入，没有异常。</strong>如果当前存在事务，就加入该事务。如果当前不存在事务，就抛出异常。</p></li><li><p><strong>PROPAGATION_REQUIRES_NEW：不管有没有，都直接创建新事务。</strong>无论当前存不存在事务，都要创建新的事务。</p></li><li><p><strong>PROPAGATION_NOT_SUPPORTED：有则挂起(暂停)当前事务。</strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起(暂停)。</p></li><li><p><strong>PROPAGATION_NEVER：有则抛出异常。</strong>以非事务方式执行，如果当前存在事务，则抛就在出异常。</p></li><li><p><strong>PROPAGATION_NESTED：如果没有事务就新建事务，如果有则在当前事务内嵌套执行。</strong>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。</p><p>外围方法没有事务：和REQUIRED一样，新建事务。</p><p>外围方法如果存在事务：嵌套事务。即外围事务回滚，内嵌事务一定回滚，而内嵌事务可以单独回滚而不影响外围主事务和其他子事务。</p></li></ol></blockquote></li></ul><hr><ul><li><h4 id="Spring事务的回滚机制"><a href="#Spring事务的回滚机制" class="headerlink" title="Spring事务的回滚机制"></a>Spring事务的回滚机制</h4><blockquote><p><strong>Spring的AOP，即声明式事务管理，默认是针对Runtime Exception回滚，即出现运行时异常进行回滚。</strong></p><p>unchecked exception(RuntimeException) 运行时异常   checked exception 编译时异常</p><p><strong>Spring的事务边界是在调用业务方法之前开始的，业务方法执行完毕后来执行commit or rollback</strong></p><p>如果你在方法中有 try{}catch(Exception e){} 处理，那么 try 里面的代码块就脱离了事务的管理，导致异常无法抛出，自然导致事务失效。若要事务生效需要在 catch 中 throw new RuntimeException (“xxxxxx”); 这一点也是面试中会问到的事务失效的场景。</p></blockquote></li></ul><hr><ul><li><h4 id="事务失效相关场景"><a href="#事务失效相关场景" class="headerlink" title="事务失效相关场景"></a>事务失效相关场景</h4><blockquote><ul><li><p><strong>在非Public修饰的方法上使用</strong></p><p>@Transactional注解使用的是AOP，在使用动态代理的时候只能针对public方法进行代理，如果不是标注在public修饰的方法上，并不会抛出异常，但是会导致事务失效。</p></li><li><p><strong>异常被”踹死了”</strong></p><p>这是最容易犯的错误，在整个事务方法中使用了try-catch，导致了异常无法抛出，自然会导致事务失效。</p></li><li><p><strong>方法中调用了同类的方法</strong></p><p>一个类中的A方法(未标注声明式事务)，在内部调用了B方法(标注了声明式事务)，这样会导致B方法中的事务失效。</p><p><strong>为什么会失效？</strong>因为Spring在扫描Bean的时候会自动为标注了@Transactional注解的类生成一个代理类(proxy)，当有注解的方法被调用的时候，实际上是代理类调用的，代理类在调用之前会开启事务，执行事务的操作，但是同类中的方法互相调用，相当于this.B()，此时B方法并非是代理类调用，而是直接通过原有的Bean直接调用，所以注解会失效。</p></li><li><p><strong>rollbackFor&#x2F;noRollbackFor属性设置错误</strong></p><p>指定异常触发回滚，如果设置错误，导致异常不能触发回滚，此时声明式事务就会失效。</p></li><li><p><strong>底层数据库引擎不支持事务</strong></p></li><li><p><strong>使用了错误的传播特性</strong></p><p>当配置了错误的传播特性，也会导致事务失效，如：Propagation.SUPPORTS，Propagation.NOT_SUPPORTED，Propagation.NEVER</p></li><li><p><strong>。。。</strong></p></li></ul></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是SpringMVC</title>
      <link href="/2022/08/19/%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC/"/>
      <url>/2022/08/19/%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="SpringMVC相关知识"><a href="#SpringMVC相关知识" class="headerlink" title="SpringMVC相关知识"></a>SpringMVC相关知识</h3><blockquote><ol><li>什么是SpringMVC</li><li>SpringMVC的优点</li><li>SpringMVC的原理及工作流程</li><li>SpringMVC的作用</li><li>相关扩展</li></ol></blockquote></li><li><h4 id="什么是SpringMVC？"><a href="#什么是SpringMVC？" class="headerlink" title="什么是SpringMVC？"></a>什么是SpringMVC？</h4><blockquote><p><strong>SpringMVC是Spring提供的一个基于MVC设计模式的轻量级Web开发框架。</strong>即使用了MVC架构模式的思想(通过把Model，View，Controller分离)，将Web层进行职责解耦，把复杂的Web应用分为逻辑清晰的几部分，简化开发，减少出错。本质上相当于Servlet。</p></blockquote></li></ul><hr><ul><li><h4 id="什么是MVC设计模式？"><a href="#什么是MVC设计模式？" class="headerlink" title="什么是MVC设计模式？"></a>什么是MVC设计模式？</h4><blockquote><p>MVC是表现层的设计模式，与其他层没有关系。</p><p>MVC分别是：<strong>模型mode</strong>l(javabean)，<strong>视图view</strong>(jsp&#x2F;img)，<strong>控制器Controller</strong>(Action&#x2F;servlet)。</p><p>C的存在目的就是为了保证M和V的一致性，当M发生改变时，C可以把M中的新内容更新到V中。</p><p>最经典的MVC设计模式就是：JavaBean+JSP+Servlet</p></blockquote></li></ul><hr><ul><li><h4 id="SpringMVC的优点"><a href="#SpringMVC的优点" class="headerlink" title="SpringMVC的优点"></a>SpringMVC的优点</h4><blockquote><ul><li><p><strong>清晰的角色划分。</strong>SpringMVC在Model，View，Controller方面提供了非常清晰的角色划分，每个角色都可以由一个专门的对象来实现。前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。真正做到了各司其职，各负其责。</p></li><li><p><strong>分层设计。</strong>实现了业务系统各个组件之间的解耦，有利于业务系统的可拓展性，可维护性。</p></li><li><p><strong>灵活的配置功能。</strong>可以把类当作Bean通过XML进行配置。</p></li><li><p><strong>有利于系统的并行开发，提高开发效率。</strong>由于按层把系统分开，所以能够更好的实现开发中的分工，网页设计人员可以进行视图层JSP的开发，业务开发人员则可以进行业务层开发，其他人员则可以进行控制层的开发。</p></li><li><p><strong>可以支持各种视图技术，而不仅仅局限于JSP。</strong>SpringMVC不会强制开发者使用JSP，可以根据项目需求使用Velocity，FreeMarker等技术。</p></li><li><p><strong>支持各种请求资源的映射策略。</strong>并且支持RESTful编程风格的请求。</p></li><li><p><strong>灵活性强，可以与其他Spring的其他框架无缝集成(IOC，AOP)。</strong>因为与SpringIOC容器做到了无缝集成，这意味着，Spring提供的任何特性，在SpringMVC中都可以使用。</p></li><li><p><strong>支持国际化。可以根据用户区域显示多国语言。</strong></p></li><li><p><strong>提供了一个前端控制器DispatcherServlet，使开发人员无需额外开发控制器对象。</strong></p></li></ul></blockquote></li></ul><hr><ul><li><h4 id="SpringMVC的原理-x2F-工作流程"><a href="#SpringMVC的原理-x2F-工作流程" class="headerlink" title="SpringMVC的原理&#x2F;工作流程"></a>SpringMVC的原理&#x2F;工作流程</h4><blockquote><p>在没有使用SpringMVC之前，我们都是使用Servlet进行Web开发，但是使用Servlet在请求参数，数据共享，页面跳转等操作相对复杂。Servlet是Java进行Web开发的标准，<strong>既然SpringMVC是对Servlet的封装，那么很显然SpringMVC的底层就是Servlet。</strong></p><p><strong>SpringMVC工作流程：</strong></p><ol><li>用户发送请求至前端控制器<strong>DispatcherServlet。</strong></li><li><strong>DispatcherServlet</strong>收到请求后，调用<strong>HandlerMapping</strong>处理器映射器，请求获取<strong>Handler</strong>。</li><li>处理器映射器<strong>根据请求url</strong>找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给<strong>DispatcherServlet。</strong></li><li><strong>DispatcherServlet</strong>调用<strong>HandlerAdapter</strong>处理器适配器。</li><li><strong>HandlerAdapter</strong>经过适配调用具体的处理器。(<strong>Handler</strong>，也叫后端控制器)</li><li><strong>Handler</strong>执行完成返回<strong>ModelAndView</strong>。</li><li><strong>HandlerAdapter</strong>将<strong>Handler</strong>执行结果<strong>ModelAndView</strong>返回给<strong>DispatcherServlet。</strong></li><li><strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>传给<strong>ViewResolver</strong>视图解析器进行解析。</li><li><strong>ViewResolver</strong>解析后返回具体的<strong>View。</strong></li><li><strong>DispatcherServlet</strong>对<strong>View</strong>进行渲染视图(即将模型数据填充至视图中)。</li><li><strong>DispatcherServlet</strong>响应用户。</li></ol><p><strong>组件说明：</strong></p><ul><li><p><strong>DispatcherServlet：前端控制器。</strong>整个流程控制的中心，控制其他组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</p></li><li><p><strong>HandlerMapping：处理器映射器。</strong>根据用户请求找到对应具体的<strong>Handler</strong>处理器。</p></li><li><p><strong>Handler：处理器。</strong>业务处理的核心类，通常由开发者编写，描述具体的业务。</p></li><li><p><strong>HandlerAdapter：处理器适配器。</strong>通过它对处理器进行执行。</p></li><li><p><strong>ViewResolver：视图解析器。</strong>由框架提供，进行视图解析，将处理结果生成View视图。</p></li><li><p><strong>View：视图。</strong>最终产出结果，常用视图有JSP，HTML。</p></li></ul></blockquote></li></ul><hr><ul><li><h4 id="SpringMVC的作用"><a href="#SpringMVC的作用" class="headerlink" title="SpringMVC的作用"></a>SpringMVC的作用</h4><blockquote><p>在原先的Web开发中，用户发起请求后，由Tomcat对原始请求进行封装，封装成request对象，再封装响应对象response，最后根据用户的请求路径找到对应的Servlet，Servlet处理后将结果封装到response中，最后由Tomcat核心返回最终的响应体。</p><hr><p>我们可以发现，一旦项目中需要定义多个Servlet来处理不同模块的请求，而每个Servlet中都有一些共同的动作需要执行，我们往往需要花费一定的精力来写这些重复性代码。</p><p><strong>如何简化这些重复性代码，或者说将这些方法抽取出来呢？</strong></p><p>SpringMVC做的就是这件事，它将Servlet共有的重复性动作给抽取出来，开发者不再需要写Servlet，可以更加专注于业务逻辑的开发。即<strong>SpringMVC就是抽取了我们Web开发的共有部份，简化了开发。</strong></p></blockquote></li></ul><hr><ul><li><h4 id="SpringMVC如何与Ajax相互调用？"><a href="#SpringMVC如何与Ajax相互调用？" class="headerlink" title="SpringMVC如何与Ajax相互调用？"></a>SpringMVC如何与Ajax相互调用？</h4><blockquote><p><strong>通过Jackson框架把Java对象转换成js可以识别的json对象</strong></p><p>步骤：</p><ol><li><p>加入jackson.jar</p></li><li><p>配置json的映射</p></li><li><p>在接收Ajax方法里直接返回Object，List等，方法前要加@RequestBody注解</p></li></ol><p>PS. </p><p>什么是Ajax：Ajax是一种在无需重新加载整个网页的情况下，能够更新部份网页的技术。</p><p>Ajax的全称是Asynchronous JavaScript and XML，即<strong>异步JavaScript+XML。</strong></p><p>作用：与服务器进行数据交换，异步交互。</p></blockquote></li></ul><hr><ul><li><h4 id="SpringMVC怎样设定重定向和转发？"><a href="#SpringMVC怎样设定重定向和转发？" class="headerlink" title="SpringMVC怎样设定重定向和转发？"></a>SpringMVC怎样设定重定向和转发？</h4><blockquote><p>一般情况下，控制器方法返回字符串类型的值会被当成逻辑视图名处理。</p><p>如果返回的字符串中带 <strong>forward:</strong> 或 <strong>redirect:</strong> 前缀时，SpringMVC会对他们进行特殊处理，</p><p>将 **forward:  &#x2F;  redirect:**当成指示符其后的字符串作为URL来处理。</p><p>**转发：在返回值前面加”forward:”**，譬如”forward:user.do?name&#x3D;method4”</p><p>**重定向：在返回值前面加”redirect:”**，譬如”redirect:<a href="http://www.google.com&quot;/">http://www.google.com&quot;</a></p></blockquote></li></ul><hr><ul><li><h4 id="介绍一下WebApplicationContext"><a href="#介绍一下WebApplicationContext" class="headerlink" title="介绍一下WebApplicationContext"></a>介绍一下WebApplicationContext</h4><blockquote><p>WebApplicationContext是<strong>专门为Web设计的。它允许从相对于Web根目录的路径中装载配置文件完成初始化工作。</strong></p><p>WebApplicationContext继承了ApplicationContext并增加了一些Web应用必备的特有功能，它不同于一般的ApplicationContext，因为它能处理主题，并找到被关联的Servlet。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Spring</title>
      <link href="/2022/08/08/%E4%BB%80%E4%B9%88%E6%98%AFSpring/"/>
      <url>/2022/08/08/%E4%BB%80%E4%B9%88%E6%98%AFSpring/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="Spring相关知识"><a href="#Spring相关知识" class="headerlink" title="Spring相关知识"></a>Spring相关知识</h3></li></ul><blockquote><p>1.Spring是什么？</p><p>2.为什么要用Spring？</p><p>3.Spring有什么好处？</p><p>4.Spring中两大核心知识点是什么？</p></blockquote><ul><li><h4 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a><strong>什么是Spring</strong></h4></li></ul><blockquote><p>首先我们来Spring官方文档中对Spring的定义</p><p>What We Mean by “Spring”</p><p>The term “Spring” means different things in different contexts. <strong>It can be used to refer to the Spring Framework project itself, which is where it all started</strong>.Over time, other Spring projects have been built on top of the Spring Framework.<strong>Most often, when people say”Spring”, they mean the entire family of projects.</strong></p><p>简单翻译一下：”spring”在不同的环境中，代表的含义不同。它可以指代项目本身，spring这个词就是从这里开始的，随着时间的推移，其他的spring项目又基于Spring Framework产生。所以，大多数情况下，当人们谈到”Spring”的时候，他们的意思就是整个spring项目家族.</p><p>所以，通过官方文档，我们可以知道，从广义上理解，spring就是spring全家桶的核心基础，一款轻量级开源框架.</p><p>从狭义上理解，spring指的就是Spring Framework，特别是其中的核心概念和思想</p><p><strong>简言之，Spring就是一个框架，它能够统一管理各种Bean组件，由于其自身的高拓展性，方便与其他第三方软件集成，进而简化和加速软件开发过程</strong></p></blockquote><ul><li><h4 id="为什么要用Spring"><a href="#为什么要用Spring" class="headerlink" title="为什么要用Spring"></a><strong>为什么要用Spring</strong></h4></li></ul><blockquote><ol><li><p><strong>首先，是为了避免重复造轮子。</strong>因为Spring已经成为了Java开发的业界标准，经过多年的沉淀已经无数项目得实战检验，大家都是基于此框架进行开发，进而减少了没必要的交流。如果遇到问题也可以向同样使用此框架的刃进行交流。</p></li><li><p><strong>学习掌握Spring的理念。</strong>Spring作为当前最流行的框架之一，大部分企业都在使用，则必然有先进的理念所支撑，并且大家都已经认同Spring的理念，诸如IOC,AOP等。</p></li><li><p><strong>同时，Spring对很多异构技术提供了统一的编码模型。</strong>例如Spring Data，在开发环境中，当我们遇到多种数据库类型时(NoSQL，SQL)，Spirng Data为我们提供了一组的API接口，用统一的方式去做数据库持久化的开发。</p></li></ol></blockquote><ul><li><h4 id="Spring有什么好处"><a href="#Spring有什么好处" class="headerlink" title="Spring有什么好处"></a>Spring有什么好处</h4></li></ul><blockquote><ol><li><p><strong>简化配置 ：</strong>简化了SSM框架中对组件扫描，注释驱动等配置的编写，同时<strong>支持声明式事务处理</strong>，通过配置完成对事务的管理，无需手动编程。</p></li><li><p><strong>免费开源 ：</strong>Spring作为开源框架，为程序员提供了方便的同时，也为公司节省了成本。</p></li><li><p><strong>方便解耦，简化开发，并且兼容性强大：</strong>Spring框架简单来说就是一个大工厂，可以将所有对象的创建和依赖关系的维护都交给Spring容器进行管理，降低了组件之间的耦合性。</p></li><li><p><strong>AOP编程的支持：</strong>Spring的核心为<strong>IOC</strong>与<strong>AOP</strong>，它允许将一些通用的任务，<strong>安全，事务，日志</strong>等进行集中式处理，提高程序的复用性。</p></li><li><p><strong>方便对程序进行测试：</strong>Spring提供了对Junit4的支持，可以方便的使用注解对Spring程序继续测试</p></li><li><p><strong>方便集成各种优秀框架：</strong>Spring作为一款开源框架，并不排斥其他优秀的框架，其内部提供了对各种优秀框架的直接支持，如<strong>Hibernate、MyBatis</strong>。</p></li><li><p>1</p></li><li><p><strong>降低了Java EE中API的使用难度：</strong>Spring对Java开发中非常难用的一些API提供了封装，使其使用难度大大降低，如JDBC</p></li></ol></blockquote><ul><li><h4 id="Spring核心知识点：IOC-控制反转"><a href="#Spring核心知识点：IOC-控制反转" class="headerlink" title="Spring核心知识点：IOC  (控制反转)"></a>Spring核心知识点：IOC  (控制反转)</h4></li></ul><blockquote><ul><li><h4 id="Spring-IOC解决的是对象管理以及对象依赖问题"><a href="#Spring-IOC解决的是对象管理以及对象依赖问题" class="headerlink" title="Spring IOC解决的是对象管理以及对象依赖问题"></a><strong>Spring IOC解决的是对象管理以及对象依赖问题</strong></h4></li></ul><ol><li><p>IOC是Inversion Of Control的缩写，意为控制反转，<strong>即把原有自己掌控的事情交给别人来处理，旨在解决程序间的耦合问题。</strong></p></li><li><p><strong>IOC控制反转，它更多的指的是一种思想，或者设计模式。</strong>本来是由我们自己手动创建(new)对象，现在则把对象交给Spring的IOC容器来创建管理。所以可以把IOC容器理解为一个对象工厂，工厂管理这些对象的创建以及依赖关系，当我们需要使用对象的时候，则直接从工厂获取。</p><p>IOC的工作原理就是<strong>工厂模式+反射机制</strong></p></li><li><p><strong>控制反转是一种思想，而依赖注入是其实现方式。</strong>依赖注入，指的是对象无需自行创建或者管理它的依赖关系，依赖关系将自动注入到需要它的对象中。其中有4种常用的注入方式：<strong>set，构造器，静态工厂，实例工厂</strong>。通过<strong>注解</strong>或者<strong>xml配置文件</strong>进行实现</p></li></ol><ul><li><strong>为什么要用Spring IOC</strong></li></ul><ol><li><p>明明可以自己new出来对象，为什么要交给IOC容器进行管理？</p><p><strong>主要的好处在于可以将对象进行集中统一的管理，并且降低耦合度</strong></p><ul><li><p>理论上我们可以自己new对象，但是自己创建的对象需要我们自己去管理，可能需要实现很多复杂的条件才能满足需求。比如要实现对象增强，还得自己创建代理，但是通过Spring则可以使用AOP进行实现，因为AOP的底层是动态代理技术。</p></li><li><p>所以，在企业项目开发中，对象的创建不单单是new一下就完事了，还要考虑多个实现类，对象之间的依赖关系，单元测试，单例等复杂的问题，这就是我们为什么要用Spring IOC。</p></li></ul></li></ol></blockquote><ul><li><h4 id="Spring核心知识点：AOP-面向切面编程"><a href="#Spring核心知识点：AOP-面向切面编程" class="headerlink" title="Spring核心知识点：AOP(面向切面编程)"></a>Spring核心知识点：AOP(面向切面编程)</h4></li></ul><blockquote><ul><li><h4 id="Spring-AOP解决的是非业务代码抽取的问题"><a href="#Spring-AOP解决的是非业务代码抽取的问题" class="headerlink" title="Spring AOP解决的是非业务代码抽取的问题"></a>Spring AOP解决的是非业务代码抽取的问题</h4></li></ul><ol><li><p><strong>什么是AOP？</strong>AOP一般称为面向切面编程，其实就是在方法前后增加非业务代码，对其进行增强</p></li><li><p><strong>AOP底层的技术是动态代理</strong>，其在Spring内实现依赖的是BeanPostProcessor。当我们需要在方法上注入重复性的非业务代码时，就可以利用Spring AOP，将这些非业务代码抽取并封装为一个可重用的模块，这个模块就被称为<strong>切面(Aspect)，</strong>减少系统中的重复代码，降低模块间的耦合度，并提高系统的可维护性。其中真正被拦截并增强的方法，被称为<strong>切入点(Pointcut)。</strong></p></li><li><p>在Spring AOP种，切面的工作被称为<strong>通知(Advice)，</strong>其中有5种类型的通知：</p><ul><li><strong>前置通知（Before）：</strong>在目标方法被调用前被调用</li><li><strong>最终通知（After）：</strong>在目标方法执行后执行，不论目标方法是否正常执行完成</li><li><strong>后置通知（After-returning ）：</strong>在目标方法<strong>成功执行</strong>后执行，可以通过配置得到返回值</li><li><strong>异常通知（After-throwing）：</strong>在目标方法抛出异常时执行</li><li><strong>环绕通知（Around）：</strong>在目标方法执行前后都可以执行额外代码，包裹目标方法</li></ul></li><li><p>5种通知的常见使用场景</p><ul><li><strong>前置通知：</strong>记录日志（方法被调用）</li><li><strong>最终通知：</strong>记录日志（方法已调用，但不一定成功）</li><li><strong>后置通知：</strong>记录日志（方法已成功调用）</li><li><strong>异常通知：</strong>异常处理、控制事务</li><li><strong>环绕通知：</strong>控制事务、权限控制</li></ul></li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关注解</title>
      <link href="/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring系列相关注解"><a href="#Spring系列相关注解" class="headerlink" title="Spring系列相关注解"></a><strong>Spring系列相关注解</strong></h3><blockquote><p>为什么要使用SpringMVC全注解开发模式？</p><p>1.采用纯java代码，不再需要配置繁杂的xml文件,相对于xml更简洁方便</p><p>2.减少复杂配置文件的同时亦能享受到SpringIOC容器所提供的功能</p><p>3.享受面向对象带来的好处</p><p>4.开发过程中.java与.xml文件的不断切换会造成思维上的不连贯，降低开发效率</p><p>5.通过注解与JavaBean的结合，既减少了配置文件的体积，又增加了JavaBean的可读性与内聚性</p><p>6.Spring配置的流行趋势</p></blockquote><ul><li><blockquote><h4 id="Spring工厂相关注解"><a href="#Spring工厂相关注解" class="headerlink" title="Spring工厂相关注解"></a><strong>Spring工厂相关注解</strong></h4></blockquote></li></ul><ol><li><p><strong>@Configuration</strong>  : 表示当前的类是一个<strong>配置类</strong>，作用类似于  applicationContext.xml</p></li><li><p><strong>@Bean</strong>：<strong>将当前方法的返回值注册到 Spring 容器中</strong>，作用类似于配置文件里面的 Bean 标签</p></li><li><p><strong>@Resource（name&#x3D;“xx”）</strong>：按照名字去查找 bean</p></li><li><p><strong>@Component</strong>：<strong>把当前类装配进Spring容器</strong>，默认以类名作为id,类名首字母小写</p></li><li><p><strong>@Import：导入分配置类</strong></p></li></ol><ul><li><blockquote><h4 id="包扫描相关注解"><a href="#包扫描相关注解" class="headerlink" title="包扫描相关注解"></a><strong>包扫描相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Repository</strong>：一般加在 <strong>dao</strong> 层，同@Component</li><li><strong>@Service</strong>：一般加在 <strong>service</strong> 层，同@Component</li><li><strong>@Controller</strong>：一般加在 <strong>servlet &#x2F; Controller</strong> 层，同@Component</li><li><strong>@ComponentScan</strong>：<strong>表示组件扫描</strong>，默认会扫描所有的 @Repository、@Service、@Controller和@Component。其中，这个注解可以加 basePackages 属性：如果不指定，则默认扫描的是当前配置类下面所在的包的所有类；如果加了这个属性，则当前包，以及当前包下的子包，都会扫描</li><li><strong>@Autowired</strong>：自动装填，从Spring容器中寻找对象注入</li></ol><ul><li><blockquote><h4 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a><strong>AOP相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Aspect</strong>：表示当前类是一个切面</li><li><strong>@Before：</strong>前置通知(在原始切入点方法前运行)</li><li><strong>@AfterReturning：</strong>后置通知(方法正常执行完毕后运行)</li><li><strong>@AfterThrowing：</strong>异常通知(抛出异常后通知)</li><li><strong>@After：</strong>最终通知(不论方法是否正常运行都会最后执行)</li><li><strong>@Around：</strong>环绕通知(最简单强大，在原始切入点方法前后运行)</li></ol><ul><li><blockquote><h4 id="Prooerties文件相关注解"><a href="#Prooerties文件相关注解" class="headerlink" title="Prooerties文件相关注解"></a><strong>Prooerties文件相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@PropertySource（classpath: xx.properties）：</strong>引入Properties配置文件，这个注解的作用类似于配置文件中的 context:property-placeholder</li><li><strong>@Value（”${ xx.xxxx }”）：</strong>从Spring 容器中取回 peroperties 配置文件中对应的值，返回赋予给某个变量。<strong>用在变量上面，为普通类型属性注入内容</strong></li></ol><ul><li><blockquote><h4 id="事务相关注解"><a href="#事务相关注解" class="headerlink" title="事务相关注解"></a><strong>事务相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Transactional：</strong>开启事务，凡是加了这个注解的方法，都有事务，这个注解可以放在类上也可以放在方法上，如果放在类上，则表示该类下所有的方法都有事务。如果使用在方法上，则需要在Public方法上加此注解，否则不会生效</li><li><strong>@EnableTransactionManagement：</strong>开启事务注解，一般用在配置类&#x2F;启动类上</li></ol><ul><li><blockquote><h4 id="SpringMVC相关注解"><a href="#SpringMVC相关注解" class="headerlink" title="SpringMVC相关注解"></a><strong>SpringMVC相关注解</strong></h4></blockquote></li></ul><ol><li><p><strong>@RestController：</strong>这个注解是@ResponseBody 和 @Controller 注解的组合注解，意思是既是接口层，又不需要把返回值当作视图处理，是什么数据就直接返回什么数据</p></li><li><p><strong>@RequestMapping（”&#x2F;xxx”）：</strong>如果加在方法上，标记当前方法喂一个接口，里面的xxx就是请求的URL地址，<strong>统一当前类下面的所有方法的访问路径前缀</strong></p></li><li><p><strong>@RequestParam(value&#x3D;“xx”)：</strong>指定接收前端传过来的参数的别名，加了此注解的参数必须不能为null，不然会报错</p></li><li><p><strong>@PathVariable：</strong>映射URL中绑定的占位符，即<strong>接收请求路径中占位符的值</strong></p></li><li><p><strong>@JsonFormat（pattern&#x3D;“时间格式”）：</strong>进行时间格式化，加在实体类属性上面</p></li><li><p><strong>@RequestBody：</strong>主要用来接收前端传给后端的<strong>Json字符串中的数据</strong></p></li></ol><ul><li><blockquote><h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a><strong>全局异常处理</strong></h4></blockquote></li></ul><ol><li><strong>@ControllerAdvice：</strong>定义全局异常处理器，这是一个增强的处理器，其他处理器抛出异常，都会进入这里执行</li><li><strong>@ExceptionHandler（xx.class）：</strong>指定该方法要处理的异常，只有<strong>指定的异常被抛出</strong>时才会执行此方法</li></ol><ul><li><blockquote><h4 id="SpringBoot相关注解"><a href="#SpringBoot相关注解" class="headerlink" title="SpringBoot相关注解"></a><strong>SpringBoot相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@SpringBootApplication：</strong>说明当前类是一个配置类，类似于config的效果</li><li><strong>@EnableAutoConfiguration：</strong>开启自动化配置</li></ol><ul><li><blockquote><h4 id="整合Servlet"><a href="#整合Servlet" class="headerlink" title="整合Servlet"></a><strong>整合Servlet</strong></h4></blockquote></li></ul><ol><li><strong>@ServletComponentScan：</strong>扫描web基础组件，包括servlet,listener,filter</li></ol><ul><li><blockquote><h4 id="Mapper相关注释"><a href="#Mapper相关注释" class="headerlink" title="Mapper相关注释"></a><strong>Mapper相关注释</strong></h4></blockquote></li></ul><ol><li><strong>@Mapper：</strong>表示当前接口是一个mapper，<strong>用在mapper接口层的类上</strong>，每个mapper都需要此注释，如果不加批量扫描注解代替</li><li><strong>@MapperScan（“xxx”）：</strong>批量扫描xxx路径(全路径)下的所有mapper，此注解应加在SpringBoot启动类上</li></ol><ul><li><blockquote><h4 id="Swagger相关注解"><a href="#Swagger相关注解" class="headerlink" title="Swagger相关注解"></a><strong>Swagger相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Api(tags&#x3D;“xxx”)：</strong>主要加在Controller类上，表示对类的说明</li><li><strong>ApiModel：</strong>一般加在实体类中，用来描述实体类</li><li><strong>ApiModelProperty：</strong>描述实体类的属性，加在实体类中的属性上</li><li><strong>@ApiOperation：</strong>该注解可以描述这个接口的实际作用。用在方法上面</li><li><strong>@ApiImplicitParams：</strong>表示一组参数的说明</li><li><strong>@ApiImplicitParam：</strong>指定一个参数的各方面属性，用在@ApiImplicitParams注解中</li></ol><ul><li><blockquote><h4 id="Redis相关注解"><a href="#Redis相关注解" class="headerlink" title="Redis相关注解"></a>Redis相关注解</h4></blockquote></li></ul><ol><li><strong>@EnableCaching：</strong>开启redis缓存功能，此注解应加在SpringBoot启动类上</li><li><strong>@Cacheable：</strong>在方法执行前spring会先查看缓存中是否存有数据，如果有，则直接返回缓存数据，如果没有，调用方法并将方法返回值存入缓存</li><li><strong>@CachePut：</strong>将方法的返回值放到缓存中</li><li><strong>@CacheEvict：</strong>将一条或多条数据从缓存中删除</li></ol><ul><li><strong>Coming soon…</strong></li></ul><p><img src="/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/Develop\MyBlog\source_posts\Spring相关注解\category.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2020/10/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/10/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote><ul><li>多线程基础</li><li>多线程并发的三个特性</li><li>如何解决线程安全问题</li><li>线程池</li><li>任务队列</li><li>自定义线程池</li><li>公平锁和非公平锁</li></ul></blockquote></li></ul><hr><ul><li><h4 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h4><blockquote><ol><li><h4 id="什么是多线程？"><a href="#什么是多线程？" class="headerlink" title="什么是多线程？"></a><strong>什么是多线程？</strong></h4>在了解Java多线程之前，首先要知道在操作系统中什么是线程，什么是进程。<strong>进程就是一个内存中运行的应用程序，</strong>每个进程都有个独立的内存空间，就像我们在电脑上运行QQ，用QQ音乐听歌，玩一个游戏，这些都是一个进程。<strong>线程就是程序中做的事情，</strong>就像打开QQ进行聊天，每开启一个聊天窗口，就相当于开启一个线程。所以一个进程中可以有多个线程，并且至少有一条线程。<strong>进程是操作系统分配和调度的最小单元，线程则是CPU调度的最小单元。</strong>所以<strong>多线程指的就是在同一程序中有多个线程在执行。</strong></li></ol><hr><ol start="2"><li><h4 id="多线程的创建方式是什么？"><a href="#多线程的创建方式是什么？" class="headerlink" title="多线程的创建方式是什么？"></a><strong>多线程的创建方式是什么？</strong></h4><p>我们可以通过4种方式创建多线程：</p><p><strong>继承Thread类；实现Runnable接口；实现Callable接口(有返回值)；创建线程池。</strong></p><p><strong>通常情况下，我们会通过实现Runnable接口而非继承Thread类来创建多线程，</strong>这是因为<strong>在Java中，不允许多继承，</strong>所以实现Runnable接口可以再继承其他的类，基于这个特点，Runnable接口可以实现<strong>多个相同的程序代码的线程去共享同一资源，增强了程序的健壮性，</strong>同时也<strong>避免了Java中单继承的局限性。</strong>因为代码可以被多个线程共享，所以能<strong>保持代码和数据的独立。</strong></p></li></ol><hr><ol start="3"><li><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a><strong>守护线程</strong></h4>在Java语言中，线程一共分为两种，<strong>用户线程和守护线程。</strong>用户线程就是用户自定义创建的线程，其中主线程main方法，就是一个用户线程，而守护线程则是专门用于服务其他线程的线程，会随着主线程或用户线程的存在而存在，停止而停止。<strong>通过thread.setDaemon(true);开启守护线程。</strong></li></ol><hr><ol start="4"><li><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a><strong>线程状态</strong></h4><p>说完了如何创建线程以及线程的种类，接下来就该聊一聊线程的状态了。在Java多线程中，线程从出生到死亡一共分为5种状态，分别是<strong>新建状态，可运行状态，运行状态，阻塞状态以及死亡状态。</strong></p><p><strong>新建状态(New)：</strong>是指新创建了一个线程对象。</p><p><strong>可运行状态(Runnable)：</strong>是指线程对象创建后，其他线程调用了该方法的start()方法，此时该线程将会变成可运行状态，并不一定马上执行，具体要在什么时候执行，取决于何是获取CPU的使用权。</p><p><strong>运行状态(Running)：可运行状态的线程获取到了CPU使用权，</strong>执行程序代码。</p><p><strong>阻塞状态(Blocked)：</strong>是指当一个线程试图获取一个锁对象时，但该锁对象被其他线程所持有，此时该线程就会进入阻塞状态。其中，阻塞状态又分为<strong>无限等待(waiting)<strong>状态和</strong>计时等待(timed_waiting)<strong>状态。无限等待状态是指当前线程执行了wait()方法，而计时等待是指当前线程执行了sleep()方法。当线程进入无限等待状态执行wait()方法后不能进行自动唤醒，</strong>必须等待另一个线程调用了Notify()或NotifyAll()方法才能够进行唤醒。</strong>如果进入计时等待状态执行sleep()方法，当sleep方法执行完毕，<strong>线程会自动唤醒。</strong></p><p><strong>死亡状态(terminated)：</strong>线程中代码执行完毕后，该线程就会结束其生命周期。其中结束线程有三种方法，第一种是设置<strong>退出标志exit</strong>结束，第二种是<strong>使用interrupt()方法中断线程</strong>，第三种是使用<strong>stop()方法强行中断线程。</strong></p><p>其中stop()方法极其不推荐并且已经被弃用，因为<strong>stop()方法过于极端，会立即停止run()方法中剩余的全部工作，同时释放该线程所持有的所有锁，并抛出ThreadDeath异常。</strong>这样暴力的方式会导致一些数据被处理到一半就被终止，因此会导致数据不同步，不完整。</p></li></ol><p>join()方法则是可以让线程按顺序执行，例如 A.start()，A.join()，B.start()，就是线程B必须等线程A执行完毕才可以执行。</p><hr><ol start="5"><li><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a><strong>线程优先级</strong></h4>在多线程中我们可以通过setPriority();方法设置线程优先级，取值范围为1-10，其中10是最高优先级，1是最低。java中默认为5。</li></ol></blockquote></li></ul><hr><ul><li><h4 id="多线程并发的三个特性"><a href="#多线程并发的三个特性" class="headerlink" title="多线程并发的三个特性"></a>多线程并发的三个特性</h4><blockquote><p>讲完了线程状态这些，接着我们来聊一聊多线程的三大特性，分别是<strong>原子性，可见性以及有序性。</strong></p><p><strong>这三个特性才能保证线程的安全性。</strong></p><p><strong>原子性：</strong>是指多线程中一个或多个操作要么全部执行并且执行过程不会被任何因素打断，要么就不执行。</p><p><strong>可见性：</strong>是指当多个线程访问同一个变量时，如果一个线程对这个变量的值进行了修改，则其他线程能够立刻看到修改后的值。</p><p><strong>有序性：</strong>是指程序执行的顺序按照代码的先后顺序执行。</p><p><strong>在java中，synchronized和volatile关键字实现了可见性。而synchronized和lock保证了原子性。</strong></p></blockquote></li></ul><hr><ul><li><h4 id="如何解决线程安全问题？"><a href="#如何解决线程安全问题？" class="headerlink" title="如何解决线程安全问题？"></a>如何解决线程安全问题？</h4><blockquote><p>当我们使用多线程访问同一资源，并且多个线程中都有对资源的写操作，就很容易出现线程安全问题。java中提供了三种方式来解决多线程中线程安全的问题，分别是<strong>通过synchronized关键字来定义同步代码块，同步方法以及使用Lock锁。</strong>其中在JKD1.8之前，Lock锁的性能要比synchronized更好这是因为1.8之前synchronized是一个重量级锁，性能较差，但是在JDK1.8及其以后，synchronized进行了CAS优化后，两者性能几乎持平。</p><p>synchronized锁是自动锁，无需手动释放锁资源，而lock锁是手动锁，需要手动释放资源。</p><p><strong>同步代码块，同步方法的区别？</strong>锁的对象不同，同步方法中synchronized出现在实例方法上，一定锁的是this或者当前类，而同步代码块的锁对象可以是任意对象，我们可以对在有线程安全问题的代码中加锁，而不是整个方法，比同步方法更精确。</p><p><strong>lock 锁 与 synchronized  区别？</strong>通过之前的线程安全问题我们可以知道，synchronized是关键字，而lock则是一个接口。并且synchronized在发生异常时会自动释放占有的锁，因此不会出现死锁的情况，而lock锁在发生异常时，不会主动释放占有的锁，必须手动unlock来释放，所以可能会引起死锁的发生。死锁就是两个线程资源互相等待，如果发生死锁，我们可以通过大锁套小锁的形式来避免，如果是突发情况，则可以杀死其中一个线程，先保证业务的正常运转。当然我们也可以通过梳理业务逻辑来尽量避免发生死锁的情况。</p><p>synchronized 实现原理：JVM底层通过Monitorenter+1获得锁对象，Monitorenter-1释放锁对象，当Monitorenter &#x3D; 1 说明获得了锁，Monitorenter &#x3D; 0 时等待。</p><p><strong>ThreadLocal并不是一个Thread，而是Thread的一个局部变量。</strong></p><p>ThreadLocal是解决线程安全问题的一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。ThreadLocal是线程本地变量，如果创建了一个ThreadLocal，每个访问这个ThreadLocal变量的线程都会有这个变量的一个本地拷贝，多线程下操作这个ThreadLocal变量其实就是操作线程本地内存中的变量，起到了线程隔离的作用，避免了线程安全问题。</p><p><strong>项目中哪里会用到：全局存储用户信息。</strong></p><p>在用户登录的拦截器业务中，将token中的用户信息保存在ThreadLocal中，那么当前线程在任何地方如果需要拿到用户信息就可以通过get()方法获得。</p><p><strong>问题：内存泄漏</strong></p><p>内存泄漏就是不会再被使用的对象或者变量占用的内存不能被回收，这就是内存泄漏。因为ThreadLocal本身并不存储值，它作为一个Key来让线程从ThreadLocalMap获取value。而这个key就是内存泄漏的原因，因为ThreadLocalMap使用的是ThreadLocal的弱引用作为key，而弱引用的对象在GC时会被回收。此时key为null，value还有值，就会造成内存泄漏。而强引用的话会导致key和value都不能被回收，内存泄漏风险更高。所有ThreadLocal使用弱引用，尽量减少内存泄漏。</p><p><strong>解决方法：</strong>最好的方法就是在使用完ThreadLocal后，即使调用remove()方法释放内存空间。</p><p><strong>JUC：Java.Util.Concurrent，该类是保证线程安全的一个类。</strong></p><p>AtomicBoolean，AtomicInteger，AutomicLong</p><p><strong>ReentrantLock(可重入锁)</strong></p><p>可重入锁是实现Lock接口的一个类，支持重入性，是一个悲观锁，表示当前线程获取该锁后再次获取该锁不会被阻塞。</p><p><strong>synchronized 和 ReentrantLock的区别：</strong></p><p>二者的本质区别就是synchronized 是一个关键字，而ReentrantLock是一个类。</p><p>但是两者都是可重入锁。</p><p>ReentrantLock必须手动获取和释放锁，synchronized 是自动锁，无需手动释放和开启。</p><p>ReentrantLock只适用于同步代码块，synchronized 可以修饰类，方法，变量。</p><p><strong>ReentrantReadWriteLock(读写锁)</strong></p><p>读写锁是一种读写分离的技术，读锁共享，写锁独占。就是多个线程可以一起读数据，只有写数据的时候才会同步线程。</p></blockquote></li></ul><hr><ul><li><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><blockquote><p><strong>线程池，顾名思义就是一个存放多个线程的容器，其中的线程可以反复使用，这样做可以省去频繁创建线程对象的操作。</strong>在java中，如果每一个请求就创建一个新线程，使用完后就销毁，那样系统资源的开销是相当大的。就像吃饭一样，如果每次吃饭拿一个碗，吃完饭就把碗摔了，下次吃饭再买个新碗，这样肯定是不合理的。</p><p>由此我们可以得出使用线程池的好处：</p><p><strong>可以减低重复创建线程的资源消耗；</strong></p><p><strong>提高系统响应速度，任务到达时不必等待线程创建就可以立即执行；</strong></p><p><strong>同时也可以提高线程的可管理性，因为可以对线程池中的线程进行统一的管理，分配。</strong></p><p><strong>通过Executors线程池工具类来创建线程池Executors.newXXX</strong></p><p>其中常见的线程池有：</p><p><strong>newSingleThreadExecutor(单例线程池)：</strong>顾名思义，这个线程池中只有一个线程在工作，所有请求任务按照队列顺序执行，所以执行速度最慢。当请求任务量特别大时，所有任务堆积在队列中，会导致内存溢出。</p><p><strong>newFixedThreadPool(固定线程池)：</strong>就是创建了一个固定大小的线程池，每提交一个任务就创建一个线程，直到达到设置的值，并且一旦达到就会保持不变。但是这样也会有和单例线程池一样的缺点，当请求任务过多时也会造成内存溢出。</p><p><strong>newCachedThreadPool(缓存线程池)：</strong>创建一个缓存线程池，有多少任务进来就创建多少线程，其最大线程数是integer的最大值，Integer.MAX_VALUE。因为是有多少任务就创建多少线程，所以当突然有多个任务同时进来，会导致CPU使用率飙升，可能会导致系统宕机，严重的话也会造成内存溢出。</p><p><strong>newScheduledThreadPool(定时线程池)：</strong>创建一个能够定时以及周期性执行任务的线程池，其最大线程数也是integer的最大值，弊端同缓存线程池。</p><p><strong>其中单例线程池和固定线程池的主要问题是请求队列均采用LinkedBlockingQueue，</strong>一个链表所组成的有界阻塞队列，该队列如果没有设置容量，就会默认为integer的最大值。</p><p><strong>缓存线程池和定时线程池的主要问题是线程最大数是Integer.MAX_VALUE，</strong>可能会因为过多线程导致OOM。</p><p>因为Executors的线程池都有资源耗尽导致内存溢出的问题(OOM)，所以阿里巴巴在其阿里巴巴开发手册上写了不建议使用Executors中的线程池，而是使用自定义线程池。</p></blockquote></li></ul><hr><ul><li><h4 id="任务队列-workQueue"><a href="#任务队列-workQueue" class="headerlink" title="任务队列(workQueue)"></a>任务队列(workQueue)</h4><blockquote><p><strong>任务队列是基于阻塞队列实现的，即采用生产者，消费者模式。</strong></p><p>什么是阻塞队列？</p><p>阻塞队列BlockingQueue是JUC并发包下的一个接口。</p><p>当队列为空时，从队列中获取元素的操作将被阻塞；当队列满时，向队列中添加元素的操作将被阻塞。</p><p><strong>ArrayBlockingQueue：</strong>由数组结构组成的有界阻塞队列。</p><p><strong>LinkedBlockingQueue：</strong>由链表结构组成的有界阻塞队列，如果没有指定容量，默认为integer的最大值。所以它的有界性是optional，如果指定容量，就是有界，没有就是无界。</p><p><strong>PriorityBlockingQueue：</strong>一个支持线程优先级排序的无界队列，默认自然序，不能保证同优先级元素的顺序。</p><p><strong>SynchronousQueue：</strong>一个不存储元素的阻塞队列，消费者线程调用take()方法的时候就会发生阻塞，直到有一个生产者线程生产了一个元素，消费者线程才可以拿到这个元素并返回。</p><p>生产者线程调用put()方法的时候也会发生阻塞，直到一个消费者线程消费了一个元素，生产者线程才会返回。</p><p>有界队列：当队列饱和并超过最大线程数时就会执行拒绝策略。</p><p>无界队列：无界队列的最大容量是integer的最大值，约等于无界，因此可以无限添加任务，直至内存溢出，并不会执行拒绝策略。</p></blockquote></li></ul><hr><ul><li><h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><blockquote><p><strong>自定义线程池ThreadPoolExecutor的七大核心参数：</strong></p><ol><li><strong>corePoolSize：核心线程数</strong></li><li><strong>maximumPoolSize：最大线程数。</strong>线程池能够容纳同时执行的最大线程数</li><li><strong>keepAliveTime：临时线程最大存活时间。</strong>多于核心线程数的临时线程将在到达最大存活时间后销毁。</li><li><strong>unit：临时线程最大存活时间的时间单位。</strong></li><li><strong>workQueue：任务队列。</strong>被提交但尚未执行的任务。</li><li><strong>threadFactory：线程工厂。</strong>用于创建线程，一般为默认线程工厂。</li><li><strong>handler：拒绝策略。</strong>当任务队列满了并且工作线程大于等于线程池最大线程数，就会对其他线程使用拒绝策略。</li></ol><p>核心线程数如何合理配置：</p><p>获取机器CPU核数：<strong>Runtime.getRuntime().availableProcessors()</strong></p><p>分析线程池处理的程序是什么类型：</p><p>CPU密集型：核心线程数 &#x3D; CPU核数 + 1</p><p>I&#x2F;O密集型：核心线程数 &#x3D; CPU核数 * 2</p><p><strong>4种拒绝策略：</strong></p><ol><li><strong>AbortPolicy：丢弃抛异常。</strong>是默认的拒绝策略。</li><li><strong>DiscardPolicy：丢弃不抛异常。</strong>不推荐，因为无法判断丢弃了哪些线程。</li><li><strong>DiscardOldestPolicy：丢弃等待最久的线程。</strong></li><li><strong>CallerRunsPolicy：调用main方法执行线程。</strong></li></ol><p><strong>任务过多时，自定义线程池的执行顺序？</strong></p><p>当核心线程池满后，会进入任务队列等待，任务队列也满了后，<strong>会根据最大线程数创建临时线程(最大线程数 - 核心线程数 &#x3D; 临时线程数)执行，</strong>当临时线程也满了就会执行拒绝策略。</p><p><strong>线程池中submit()和execute()方法的区别？</strong></p><p>execute()只能执行Runnable类型的任务，submit()可以执行Runnable和Callable类型的任务。</p><p>execute()没有返回值，submit()则可以返回持有计算结果的future对象。</p></blockquote></li></ul><hr><ul><li><h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><blockquote><p><strong>公平锁：老的线程排队使用锁，新的线程同样排队使用锁</strong>。就是多个线程抢锁时，获得锁得线程一定是队列中等待时间最长的线程。</p><p>非公平锁：老的线程排队使用锁，但是无法保证新线抢占已经在排队的线程的锁。多个线程抢锁时，<strong>获得锁得线程不一定是队列中等待最长的线程</strong>，也可能是新进入队列得线程。</p><p>synchronized 是非公平锁，ReentrantLock可以通过构造方法确定是使用公平还是非公平，默认非公平，减少上下文切换，提升效率。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2020/09/06/%E9%9B%86%E5%90%88/"/>
      <url>/2020/09/06/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><blockquote><ul><li>什么是集合</li><li>ArrayList</li><li>LinkedList</li><li>HashSet</li><li>HashMap</li></ul></blockquote></li></ul><hr><ul><li><h4 id="Java中，什么是集合"><a href="#Java中，什么是集合" class="headerlink" title="Java中，什么是集合"></a>Java中，什么是集合</h4><blockquote><p><strong>在Java中，集合可以看做是一个容器，用来存放各种元素。</strong>集合分为了单列集合collection以及双列集合map，其中单列集合又包括了List以及Set集合，再往下List集合又分为了ArrayList以及LinkedList，Set集合分为HashSet以及TreeSet集合。而双列集合Map分为了TreeMap和HashMap。 </p></blockquote></li><li><h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><blockquote><p>说到List集合，其中最常用的集合就是ArrayList集合，<strong>ArrayList集合底层是基于数组来实现容量大小的动态变化，</strong>为什么会是一个数组呢？我们通过源码可以发现，其在定义集合大小size的时候，使用的是一个<strong>Object[ ]数组</strong>，因此我们可以推断，ArrayList的底层就是数组。因此我们同样可以得出其查询快，增删慢的特点，毕竟底层是数组结构嘛。</p><p>为什么会增删慢，这就要说到ArrayList集合的<strong>存储特点了：有序存储，且元素可以重复。</strong>因为要保证元素的有序，所以当对集合中的元素进行添加或者删除时，其他元素也要跟着进行移位，打个比方，集合中有10个元素时，当我要对其中第5个元素进行删除，则其后面的5个元素也要向前移动一位，以保证元素的有序排列，当集合中的元素很多时，这样的增删操作就会变得很慢。不过我想这样的说法也不严谨，当对集合进行顺序增删，即对集合中的元素进行尾部插入或者删除，那样速度应该也是很快的，毕竟不需要进行移位了。既然说到了ArrayList集合，就免不了其扩容机制。扩容就是把数组复制到另一个内存空间更大的数组中去。<strong>通过ArrayList无参构造方法可以看出，其创建了一个容量大小为10的空list集合，也就是说，当我们只是创建了对象而没有添加元素的时候，集合的初始容量其实为0，在第一次添加元素的时候，集合的容量将扩容至10。通过源码中的grow()方法可以看出，如果数组的大小大于数组的初始容量的时候，即在添加第11个元素的时候，就会进行扩容，新数组容量&#x3D;老数组容量+老数组容量的1&#x2F;2，按照原容量的1.5倍进行扩容。个人认为这个1.5是按照位运算计算而来的，所以可以说是扩容1.5倍后向下取整，因为当我数组长度为奇数时，例如数组长度为17，按照1.5倍进行扩容则为25.5，向下取整扩容后的长度为25。</strong></p><p><strong>为什么ArrayList的存储特点是有序且可重复？</strong>通过源码我们可以发现，Size的定义是通过Size++来实现，即根据下标进行有序存储。同样通过源码我们并没有发现任何对存储元素是否相同的判断，所以我们可以推断ArrayList集合可以存储重复的元素。</p><p><strong>为什么ArrayList的初始化容量为10？</strong>首先当我们在讨论HashMap的时候，我们说到HashMap的初始容量16之所以会选择2的n次方，更多的考虑的是hash算法的性能与碰撞等问题。而这个问题对于ArrayList来说并不存在，因为ArrayList只是一个简单得增长集合，不用考虑算法层面的优化。只要超过一定的值进行增长即可。所以，理论上来说ArrayList的容量是任何正值都可以。ArrayList的源码中并没有说明为什么选择10，只是说了创建一个容量为10的list集合，但很大的可能是出于性能损失与空间损失之间的最佳匹配来进行考虑。10，不是很大，也不是很小，不会浪费太多的内存空间，也不会折损太多性能。就像恋爱中的男女，女生闹脾气的时候是没有明确的原因的。</p></blockquote></li></ul><hr><ul><li><h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><blockquote><p>说完了ArrayList，接着聊聊List集合中的LinkedList集合，<strong>LinkedList集合的底层是通过双向链表来实现的，所以其优缺点与ArrayList互补，即增删快，查询慢。</strong>因为是双向链表，在进行增删操作的时候，只需要将链表的头结点和尾节点指向新插入的节点即可，不需要去移动其他元素，所以增删快。因为双向链表会通过first以及last引用分别指向链表的第一和最后一个元素，所以头插和尾插的速度是最快的。在查询方面，之所以会查询速度较慢，是因为双向链表每次查询都要从前后两端进行查询，即离头近就从前往后查，离尾近就从后往前查，一个一个查询直至寻找到目标元素，这样就会造成查询速度较慢。</p><p>其中，对于LinkedList集合新增数据比ArrayList集合快的特点，其实也不绝对，因为<strong>如果新增的数据量非常庞大，ArrayList的新增效率反而比LinkedList高，因为ArrayList底层数组是按照1.5倍进行扩容，数据越多，扩容速度越快，扩容空间越大，弥补了前期频繁扩容的s劣势，</strong>而LinkedList底层链表仍要一个个的查找索引，分配节点，去一个个的将对象new成一个node节点，并使尾指针指向新的node节点。</p></blockquote></li></ul><hr><ul><li><h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><blockquote><p><strong>HashSet的底层是通过哈希表来实现。</strong>通过翻看HashSet源码，可以看出实<strong>际上就是new了一个HashMap实例，</strong>(map &#x3D; new HashMap&lt;&gt;())。HashSet中的元素都存在HashMap键值对的Key中，而Value则是一个统一的值，一个Object()对象。(<strong>private static final Object PRESENT &#x3D; new Object();</strong>)</p><p>其实说白了HashSet就是限制了功能的HashMap，所以了解了HashMap原理，自然也能理解HashSet，接下来就来谈谈HashMap。</p></blockquote></li></ul><hr><ul><li><h4 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h4><blockquote><p>作为双列集合map中最常用的集合HashMap，是Java中非常经典的数据结构，底层通过Hash表来实现，在JDK1.8之前，Hash表的底层是<strong>数组+链表，</strong>而在JDK1.8之后，则是<strong>数组+链表+红黑树</strong>的结构。之所以会引入红黑树，是因为链表是线性存储数据的，如果元素过多，造成链表过长，会严重影响查询以及存取性能，其实本质上是为了安全而考虑的。</p><p><strong>红黑树：一种能够自平衡的二叉查找树。</strong></p><p><strong>HashMap的存储特点是无序且不可重复，</strong>通过翻看源码可以发现，HashMap存储的无序性主要是因为其元素的存储是根据存储位置的hashcode和数组的长度计算得到的。不可重复主要是因为HashMap在存入新的键值对时，如果发生哈希冲突，即两个元素通过哈希函数得到相同的角标，此时会先判断key是否相同，如果相同，会进一步对value进行比较，如果value也相同，则不存入，如果value不相同，则新存入的value会替换老的value。如果key不相同，则新的元素会以链表的形式存入老元素中。</p><p>同样的我们来看一下HashMap的扩容机制，通过翻看源码中的put()方法可以看出，HashMap的初始容量为0，当我们第一次添加元素时，会将初始容量扩容至16，之所以会是16，也是因为在位运算中，采用2的n次方可以减少hash碰撞，以及提升效率，而作为默认容量，太大太小都不合适，所以16就作为一个比较合适的值被采用。<strong>当存储的元素大于扩容阈值，则必定会进行扩容，扩容大小为原容量的2倍，</strong>而扩容阈值则是容量与默认加载因子的乘积，默认为12，即在添加第13个元素的时候进行扩容。并且当链表的长度大于等于8且数组的长度大于64的时候，链表会自动转化为红黑树，这两个条件必须同时满足，如果数组长度小于64，则会继续采用扩容策略，因为此时数组长度较小，应尽量避开红黑树。当链表长度小于等于6时，则会从红黑树转为链表。</p><p><strong>至于为什么要将链表中转红黑树的阈值设置为8，</strong>通过计算得到，<strong>链表长度符合泊松分布，即各个长度的命中概率依次递减，当长度达到8时，是最理想值，大于8的情况小于千万分之一，</strong>综合考虑选择8为链表转红黑树的阈值。</p><p><strong>为什么扩容大小是原来的2倍</strong>，因为HashMap的默认大小必定是2的n次方，在此基础上的进行2倍扩容，不会破坏这个规律。并且在进行扩容后的数据迁移时，根据二进制运算，数据要么在原位置，要么在原位置+旧容量，这样做不会改变其哈希值，效率更高。</p><p>链表转红黑树是8，红黑树转链表是6，那7是个啥？首先7是为了避免链表与红黑树之间频繁变动做的一个预留位，如果是8变6，则此时7就是红黑树，反之6变8，此时7就是链表。</p><p><strong>为什么会出现链表和红黑树之间的转换？</strong>这是因为红黑树是以空间换取时间，提升性能的同时会占据更多的内存，当节点数较少时，使用链表也可以保证查询的效率，并且使用的空间更小，毕竟链表节点只是树节点大小的1&#x2F;2。</p><p>值得一提的是，<strong>在JDK1.7中，使用的是头插法添加元素，而在JDK1.8中则是使用尾插法添加元素。</strong>之所以会进行这样的更改，是因为头插法在扩容时会改变链表中元素原本的顺序，以至于在并发环境下会导致链表成环的问题。为了解决这样的问题，在1.8中，采取尾插法，在扩容的时候不会改变元素原本的顺序，进而大大避免了环链的问题。</p><p><strong>在JDK1.7中，在放入key之前会先扩容，</strong>放入后不重新判断是否扩容。达到阈值且hash冲突时才会扩容。如果不发生hash冲突，可超过阈值。(存在理想状态下不扩容时的最大容量12+15)。</p><p><strong>在JDK1.8中，对其进行了优化，先放入key再扩容，最多存放与阈值相同的key。</strong></p><p><strong>HashMap的线程并不安全，如果想要使其线程安全，则应使用ConcurrentHashMap，通过Synchronized锁和CAS来保证线程安全。</strong></p><p><strong>JDK1.7中，HashTable可以保证线程绝对安全，但是它是通过给整个线程加锁来实现。虽然保证线程的安全，但是严重影响性能，在1.8中被淘汰。</strong></p><p>HashTable初始容量为11，默认加载因子0.75。</p><p>HashMap初始容量为0，在第一次添加元素时扩容为16，默认加载因子0.75。</p><p><strong>HashMap对象的key、value值均可为null。</strong></p><p><strong>HahTable对象的key、value值均不可为null。</strong></p><p>问题出在int hash &#x3D; key.hashCode()这里，当key为null时，key.hashCode()会报空指针异常。所以HashMap改写了hashCode函数。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/13/hello-world/"/>
      <url>/2020/02/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p><strong>对搭建的博客完成大部分主题渲染，纪念一下</strong></p><p><img src="/2020/02/13/hello-world/Develop\MyBlog\themes\butterfly\source\img\tag.png"></p><p><strong>PS:博文就看心情更新吧</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
