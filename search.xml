<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring相关注解</title>
      <link href="/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring系列相关注解"><a href="#Spring系列相关注解" class="headerlink" title="Spring系列相关注解"></a><strong>Spring系列相关注解</strong></h3><blockquote><p>为什么要使用SpringMVC全注解开发模式？</p><p>1.采用纯java代码，不再需要配置繁杂的xml文件,相对于xml更简洁方便</p><p>2.减少复杂配置文件的同时亦能享受到SpringIOC容器所提供的功能</p><p>3.享受面向对象带来的好处</p><p>4.开发过程中.java与.xml文件的不断切换会造成思维上的不连贯，降低开发效率</p><p>5.通过注解与JavaBean的结合，既减少了配置文件的体积，又增加了JavaBean的可读性与内聚性</p><p>6.Spring配置的流行趋势</p></blockquote><ul><li><blockquote><h4 id="Spring工厂相关注解"><a href="#Spring工厂相关注解" class="headerlink" title="Spring工厂相关注解"></a><strong>Spring工厂相关注解</strong></h4></blockquote></li></ul><ol><li><p><strong>@Configuration</strong>  : 表示当前的类是一个<strong>配置类</strong>，作用类似于  applicationContext.xml</p></li><li><p><strong>@Bean</strong>：<strong>将当前方法的返回值注册到 Spring 容器中</strong>，作用类似于配置文件里面的 Bean 标签</p></li><li><p><strong>@Resource（name&#x3D;“xx”）</strong>：按照名字去查找 bean</p></li><li><p><strong>@Component</strong>：<strong>把当前类装配进Spring容器</strong>，默认以类名作为id,类名首字母小写</p></li><li><p><strong>@Import：导入分配置类</strong></p></li></ol><ul><li><blockquote><h4 id="包扫描相关注解"><a href="#包扫描相关注解" class="headerlink" title="包扫描相关注解"></a><strong>包扫描相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Repository</strong>：一般加在 <strong>dao</strong> 层，同@Component</li><li><strong>@Service</strong>：一般加在 <strong>service</strong> 层，同@Component</li><li><strong>@Controller</strong>：一般加在 <strong>servlet &#x2F; Controller</strong> 层，同@Component</li><li><strong>@ComponentScan</strong>：<strong>表示组件扫描</strong>，默认会扫描所有的 @Repository、@Service、@Controller和@Component。其中，这个注解可以加 basePackages 属性：如果不指定，则默认扫描的是当前配置类下面所在的包的所有类；如果加了这个属性，则当前包，以及当前包下的子包，都会扫描</li><li><strong>@Autowired</strong>：自动装填，从Spring容器中寻找对象注入</li></ol><ul><li><blockquote><h4 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a><strong>AOP相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Aspect</strong>：表示当前类是一个切面</li><li><strong>@Before：</strong>前置通知(在原始切入点方法前运行)</li><li><strong>@AfterReturning：</strong>后置通知(方法正常执行完毕后运行)</li><li><strong>@AfterThrowing：</strong>异常通知(抛出异常后通知)</li><li><strong>@After：</strong>最终通知(不论方法是否正常运行都会最后执行)</li><li><strong>@Around：</strong>环绕通知(最简单强大，在原始切入点方法前后运行)</li></ol><ul><li><blockquote><h4 id="Prooerties文件相关注解"><a href="#Prooerties文件相关注解" class="headerlink" title="Prooerties文件相关注解"></a><strong>Prooerties文件相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@PropertySource（classpath: xx.properties）：</strong>引入Properties配置文件，这个注解的作用类似于配置文件中的 context:property-placeholder</li><li><strong>@Value（”${ xx.xxxx }”）：</strong>从Spring 容器中取回 peroperties 配置文件中对应的值，返回赋予给某个变量。<strong>用在变量上面，为普通类型属性注入内容</strong></li></ol><ul><li><blockquote><h4 id="事务相关注解"><a href="#事务相关注解" class="headerlink" title="事务相关注解"></a><strong>事务相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Transactional：</strong>开启事务，凡是加了这个注解的方法，都有事务，这个注解可以放在类上也可以放在方法上，如果放在类上，则表示该类下所有的方法都有事务。如果使用在方法上，则需要在Public方法上加此注解，否则不会生效</li><li><strong>@EnableTransactionManagement：</strong>开启事务注解，一般用在配置类&#x2F;启动类上</li></ol><ul><li><blockquote><h4 id="SpringMVC相关注解"><a href="#SpringMVC相关注解" class="headerlink" title="SpringMVC相关注解"></a><strong>SpringMVC相关注解</strong></h4></blockquote></li></ul><ol><li><p><strong>@RestController：</strong>这个注解是@ResponseBody 和 @Controller 注解的组合注解，意思是既是接口层，又不需要把返回值当作视图处理，是什么数据就直接返回什么数据</p></li><li><p><strong>@RequestMapping（”&#x2F;xxx”）：</strong>如果加在方法上，标记当前方法喂一个接口，里面的xxx就是请求的URL地址，<strong>统一当前类下面的所有方法的访问路径前缀</strong></p></li><li><p><strong>@RequestParam(value&#x3D;“xx”)：</strong>指定接收前端传过来的参数的别名，加了此注解的参数必须不能为null，不然会报错</p></li><li><p><strong>@PathVariable：</strong>映射URL中绑定的占位符，即<strong>接收请求路径中占位符的值</strong></p></li><li><p><strong>@JsonFormat（pattern&#x3D;“时间格式”）：</strong>进行时间格式化，加在实体类属性上面</p></li><li><p><strong>@RequestBody：</strong>主要用来接收前端传给后端的<strong>Json字符串中的数据</strong></p></li></ol><ul><li><blockquote><h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a><strong>全局异常处理</strong></h4></blockquote></li></ul><ol><li><strong>@ControllerAdvice：</strong>定义全局异常处理器，这是一个增强的处理器，其他处理器抛出异常，都会进入这里执行</li><li><strong>@ExceptionHandler（xx.class）：</strong>指定该方法要处理的异常，只有<strong>指定的异常被抛出</strong>时才会执行此方法</li></ol><ul><li><blockquote><h4 id="SpringBoot相关注解"><a href="#SpringBoot相关注解" class="headerlink" title="SpringBoot相关注解"></a><strong>SpringBoot相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@SpringBootApplication：</strong>说明当前类是一个配置类，类似于config的效果</li><li><strong>@EnableAutoConfiguration：</strong>开启自动化配置</li></ol><ul><li><blockquote><h4 id="整合Servlet"><a href="#整合Servlet" class="headerlink" title="整合Servlet"></a><strong>整合Servlet</strong></h4></blockquote></li></ul><ol><li><strong>@ServletComponentScan：</strong>扫描web基础组件，包括servlet,listener,filter</li></ol><ul><li><blockquote><h4 id="Mapper相关注释"><a href="#Mapper相关注释" class="headerlink" title="Mapper相关注释"></a><strong>Mapper相关注释</strong></h4></blockquote></li></ul><ol><li><strong>@Mapper：</strong>表示当前接口是一个mapper，<strong>用在mapper接口层的类上</strong>，每个mapper都需要此注释，如果不加批量扫描注解代替</li><li><strong>@MapperScan（“xxx”）：</strong>批量扫描xxx路径(全路径)下的所有mapper，此注解应加在SpringBoot启动类上</li></ol><ul><li><blockquote><h4 id="Swagger相关注解"><a href="#Swagger相关注解" class="headerlink" title="Swagger相关注解"></a><strong>Swagger相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Api(tags&#x3D;“xxx”)：</strong>主要加在Controller类上，表示对类的说明</li><li><strong>ApiModel：</strong>一般加在实体类中，用来描述实体类</li><li><strong>ApiModelProperty：</strong>描述实体类的属性，加在实体类中的属性上</li><li><strong>@ApiOperation：</strong>该注解可以描述这个接口的实际作用。用在方法上面</li><li><strong>@ApiImplicitParams：</strong>表示一组参数的说明</li><li><strong>@ApiImplicitParam：</strong>指定一个参数的各方面属性，用在@ApiImplicitParams注解中</li></ol><ul><li><blockquote><h4 id="Redis相关注解"><a href="#Redis相关注解" class="headerlink" title="Redis相关注解"></a>Redis相关注解</h4></blockquote></li></ul><ol><li><strong>@EnableCaching：</strong>开启redis缓存功能，此注解应加在SpringBoot启动类上</li><li><strong>@Cacheable：</strong>在方法执行前spring会先查看缓存中是否存有数据，如果有，则直接返回缓存数据，如果没有，调用方法并将方法返回值存入缓存</li><li><strong>@CachePut：</strong>将方法的返回值放到缓存中</li><li><strong>@CacheEvict：</strong>将一条或多条数据从缓存中删除</li></ol><ul><li><strong>Coming soon…</strong></li></ul><p><img src="/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/Develop\MyBlog\source_posts\Spring相关注解\category.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/27/hello-world/"/>
      <url>/2022/07/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p><strong>对搭建的博客完成大部分主题渲染，纪念一下</strong></p><p><img src="/2022/07/27/hello-world/Develop\MyBlog\themes\butterfly\source\img\tag.png"></p><p><strong>PS:博文就看心情更新吧</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
