<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring中事务相关</title>
      <link href="/2022/08/24/Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/08/24/Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring中事务相关知识"><a href="#Spring中事务相关知识" class="headerlink" title="Spring中事务相关知识"></a><strong>Spring中事务相关知识</strong></h3><blockquote><ul><li>什么是事务</li><li>4种事务特性</li><li>5种隔离级别</li><li>7种传播行为</li><li>事务的回滚机制</li><li>事务失效场景</li></ul></blockquote><ul><li><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a><strong>什么是事务?</strong></h4><blockquote><p>事务指的是<strong>程序中一组严密的逻辑操作，组成这组操作的各个逻辑单元，要么一起成功，要么一起失败。</strong>通俗来讲，就是把多件事情当作一件事情来处理，就像是在同一条船上的人，要活一起活，要死一起死。</p></blockquote></li></ul><hr><ul><li><h4 id="Spring的4种事务特性是什么"><a href="#Spring的4种事务特性是什么" class="headerlink" title="Spring的4种事务特性是什么?"></a><strong>Spring的4种事务特性是什么?</strong></h4><blockquote><ul><li><p><strong>原子性(Atomicity)：强调事务的不可分割。</strong>整个事务中，所有的操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不存在只执行其中一部分操作。</p></li><li><p><strong>一致性(Consistency)：事务执行的前后数据的完整性必须保持一致。</strong>数据库总是从一个一致性的状态转换为另一个一致性的状态。</p></li><li><p><strong>隔离性(Isolation)：一个事务执行的过程中，不应该受到其他事务的干扰。</strong>当多个用户并发访问数据库时，数据库要为每一个用户开启事务，不能被其他事务的操作所干扰，即<strong>多个并发事务之间要相互隔离。</strong></p><p>要达到这样一种效果：对于任意两个并发的事务A和B，在事务A看来，B要么在A开始之前就已经结束，要么在A结束之后才开始。一个事务在提交之前，对于其他事务来说是不可见的。</p></li><li><p><strong>持久性(durability)：</strong>事务一旦正确提交，它对于数据库的改变是永久的。</p></li></ul></blockquote></li></ul><hr><ul><li><h4 id="Spring中事务的5种隔离级别都是什么？"><a href="#Spring中事务的5种隔离级别都是什么？" class="headerlink" title="Spring中事务的5种隔离级别都是什么？"></a>Spring中事务的5种隔离级别都是什么？</h4><blockquote><p><strong>Spring数据库中事务的隔离级别分为四种(级别递减)：</strong></p><ul><li><p><strong>Serializable (序列化)：</strong>这是数据库<strong>最高的隔离级别，</strong>这种级别下，事务会”序列化执行”，即一个一个排队执行。在这种级别下，”脏读”，”不可重复读”，”幻读”都可以被避免，但代价则是执行效率差，性能开销大。</p></li><li><p><strong>REPEATABLE READ(可重复读)：</strong>保证多次读取同一数据时，其值和事务开始时候的内容一致。<strong>即开始读取数据(事务开启)时，不再允许修改操作。</strong>可以有效避免”不可重复读”，但是无法避免”幻读”，因为幻读是由于插入或者删除操作而产生。</p><p>PS：可重复读就是专门针对”不可重复读”而制定的隔离级别，自然可以有效避免”不可重复读”，而其也是<strong>MySql默认的隔离级别。</strong></p></li><li><p><strong>READ COMMITTED(读已提交)：只能读取到已经提交了的内容。</strong>即一个事务要等到另一个事务提交后，才能读取数据。这是各种系统中最常用的一种隔离级别，也是Oracle的默认隔离级别。其保证了一个事务不会读到另一个并行事务已修改但未提交的数据，能够有效避免”脏读”，但不能避免”幻读”，”不可重复读”。该级别适用于大多数系统。</p></li><li><p><strong>Read Uncommitted(读未提交)：最低的隔离级别，事务未提交前，就可以被其他事务读取。</strong>在这种隔离级别下，查询不会加锁，也正是因为不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”，“不可重复读”，“幻读”。如无特殊情况，基本不会使用这种隔离级别。</p></li><li><p><strong>PS：DEFAULT(默认)：默认隔离级别。</strong>即使用底层数据库设置的隔离级别，数据库使用什么样的隔离级别，就用什么。</p></li></ul><p><strong>脏读，不可重复读，幻读：</strong></p><ul><li><p><strong>脏读：表示一个事务能够读取到另一个事务中还未提交的数据。</strong>即读取到了其他事务回滚前的数据。比如事务B在执行过程中修改了数据x，在未提交前，事务A读取了x，而事务B却回滚了，这样事务A就形成了脏读。也就是说，<strong>当前事务读到的数据是别的事务想要修改但是没有修改成功的数据。</strong></p><p><strong>eg：</strong>老板给员工发工资，员工工资为2.6万&#x2F;月，但是发工资时老板不小心把工资按成了2.9万&#x2F;月，此时工资虽然修改，但是事务还未提交。恰巧此时员工查看本月工资时，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚了事务，将工资改为2.6万后进行了提交。</p></li></ul><hr><p>  实际上员工工资仍然是2.6万&#x2F;月，但是员工看到的是2.6万。他看到的是老板还未提交事务时的数据。这就是脏读。</p><ul><li><p><strong>不可重复读：当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配。</strong>即事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取到的时候，发现数据不匹配了，这就是不可重复读。</p><p><strong>eg：</strong>小明本月发工资后，拿着钱去吃喝玩乐，当他买单的时候(事务开启)，收款机检测到小明银行卡中有本月工资2.6万元，此时，小明女朋友小花突然把其卡中工资全部转出充当家用(修改并提交事务)。当收款机准备扣除金额时，再次检测银行卡中金额，发现已经没钱了。</p></li></ul><hr><p>  一个事务范围内两个相同的查询却返回了不同的数据，这就是不可重复读。</p><ul><li><p><strong>幻读：当前事务读第一次取到的数据比后来读取到的数据条目少。</strong>即事务A首先根据条件索引得到N条数据，然后事务B增添了M条符合事务A搜索条件的数据，导致事务A再次读取发现有N+M条数据。</p><p><strong>eg：</strong>小明某天去买东西，花了2千元买了一部手机，然后他的女朋友小花查看他今天的消费记录(事务开启)，看到了2千元，就在这时小明又花了1万元买了一部电脑，即新增(insert)了一条消费记录并提交。当小花打印出小明的消费记录时(事务提交)，发现花了1.2万元，这就是幻读。</p></li><li><p><strong>不可重复读与幻读：两者相似，前者针对update&#x2F;delete，后者针对insert</strong></p></li><li><p>在设置数据库的隔离级别时一定要在<strong>开启事务之前。</strong></p></li></ul></blockquote></li></ul><hr><ul><li><h4 id="事务的7种传播行为？"><a href="#事务的7种传播行为？" class="headerlink" title="事务的7种传播行为？"></a>事务的7种传播行为？</h4><blockquote><p><strong>事务的传播行为：指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行。</strong>例如，方法A调用方法B时，B是继续在调用者A的事务中运行，还是自己开启一个新的事务运行，这就由B的事务传播行为决定。</p><p>事务的7种传播行为：</p><ul><li><p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。</p></li><li><p>事务传播行为是Spring框架独有的事务增强特性。</p></li></ul><ol><li><p><strong>PROPAGATION_REQUIRED：没有新建，有则加入。</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务。这是最常用的选择，同时也是Spring默认的事务传播行为。</p></li><li><p><strong>PROPAGATION_SUPPORTS：有则加入，没有则以非事务运行。</strong>如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p></li><li><p><strong>PROPAGATION_MANDATORY：有则加入，没有异常。</strong>如果当前存在事务，就加入该事务。如果当前不存在事务，就抛出异常。</p></li><li><p><strong>PROPAGATION_REQUIRES_NEW：不管有没有，都直接创建新事务。</strong>无论当前存不存在事务，都要创建新的事务。</p></li><li><p><strong>PROPAGATION_NOT_SUPPORTED：有则挂起(暂停)当前事务。</strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起(暂停)。</p></li><li><p><strong>PROPAGATION_NEVER：有则抛出异常。</strong>以非事务方式执行，如果当前存在事务，则抛就在出异常。</p></li><li><p><strong>PROPAGATION_NESTED：如果没有事务就新建事务，如果有则在当前事务内嵌套执行。</strong>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。</p><p>外围方法没有事务：和REQUIRED一样，新建事务。</p><p>外围方法如果存在事务：嵌套事务。即外围事务回滚，内嵌事务一定回滚，而内嵌事务可以单独回滚而不影响外围主事务和其他子事务。</p></li></ol></blockquote></li></ul><hr><ul><li><h4 id="Spring事务的回滚机制"><a href="#Spring事务的回滚机制" class="headerlink" title="Spring事务的回滚机制"></a>Spring事务的回滚机制</h4><blockquote><p><strong>Spring的AOP，即声明式事务管理，默认是针对Runtime Exception回滚，即出现运行时异常进行回滚。</strong></p><p>unchecked exception(RuntimeException) 运行时异常   checked exception 编译时异常</p><p><strong>Spring的事务边界是在调用业务方法之前开始的，业务方法执行完毕后来执行commit or rollback</strong></p><p>如果你在方法中有 try{}catch(Exception e){} 处理，那么 try 里面的代码块就脱离了事务的管理，导致异常无法抛出，自然导致事务失效。若要事务生效需要在 catch 中 throw new RuntimeException (“xxxxxx”); 这一点也是面试中会问到的事务失效的场景。</p></blockquote></li></ul><hr><ul><li><h4 id="事务失效相关场景"><a href="#事务失效相关场景" class="headerlink" title="事务失效相关场景"></a>事务失效相关场景</h4><blockquote><ul><li><p><strong>在非Public修饰的方法上使用</strong></p><p>@Transactional注解使用的是AOP，在使用动态代理的时候只能针对public方法进行代理，如果不是标注在public修饰的方法上，并不会抛出异常，但是会导致事务失效。</p></li><li><p><strong>异常被”踹死了”</strong></p><p>这是最容易犯的错误，在整个事务方法中使用了try-catch，导致了异常无法抛出，自然会导致事务失效。</p></li><li><p><strong>方法中调用了同类的方法</strong></p><p>一个类中的A方法(未标注声明式事务)，在内部调用了B方法(标注了声明式事务)，这样会导致B方法中的事务失效。</p><p><strong>为什么会失效？</strong>因为Spring在扫描Bean的时候会自动为标注了@Transactional注解的类生成一个代理类(proxy)，当有注解的方法被调用的时候，实际上是代理类调用的，代理类在调用之前会开启事务，执行事务的操作，但是同类中的方法互相调用，相当于this.B()，此时B方法并非是代理类调用，而是直接通过原有的Bean直接调用，所以注解会失效。</p></li><li><p><strong>rollbackFor&#x2F;noRollbackFor属性设置错误</strong></p><p>指定异常触发回滚，如果设置错误，导致异常不能触发回滚，此时声明式事务就会失效。</p></li><li><p><strong>底层数据库引擎不支持事务</strong></p></li><li><p><strong>使用了错误的传播特性</strong></p><p>当配置了错误的传播特性，也会导致事务失效，如：Propagation.SUPPORTS，Propagation.NOT_SUPPORTED，Propagation.NEVER</p></li><li><p><strong>。。。</strong></p></li></ul></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是SpringMVC</title>
      <link href="/2022/08/19/%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC/"/>
      <url>/2022/08/19/%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="SpringMVC相关知识"><a href="#SpringMVC相关知识" class="headerlink" title="SpringMVC相关知识"></a>SpringMVC相关知识</h3><blockquote><ol><li>什么是SpringMVC</li><li>SpringMVC的优点</li><li>SpringMVC的原理及工作流程</li><li>SpringMVC的作用</li><li>相关扩展</li></ol></blockquote></li><li><h4 id="什么是SpringMVC？"><a href="#什么是SpringMVC？" class="headerlink" title="什么是SpringMVC？"></a>什么是SpringMVC？</h4><blockquote><p><strong>SpringMVC是Spring提供的一个基于MVC设计模式的轻量级Web开发框架。</strong>即使用了MVC架构模式的思想(通过把Model，View，Controller分离)，将Web层进行职责解耦，把复杂的Web应用分为逻辑清晰的几部分，简化开发，减少出错。本质上相当于Servlet。</p></blockquote></li></ul><hr><ul><li><h4 id="什么是MVC设计模式？"><a href="#什么是MVC设计模式？" class="headerlink" title="什么是MVC设计模式？"></a>什么是MVC设计模式？</h4><blockquote><p>MVC是表现层的设计模式，与其他层没有关系。</p><p>MVC分别是：<strong>模型mode</strong>l(javabean)，<strong>视图view</strong>(jsp&#x2F;img)，<strong>控制器Controller</strong>(Action&#x2F;servlet)。</p><p>C的存在目的就是为了保证M和V的一致性，当M发生改变时，C可以把M中的新内容更新到V中。</p><p>最经典的MVC设计模式就是：JavaBean+JSP+Servlet</p></blockquote></li></ul><hr><ul><li><h4 id="SpringMVC的优点"><a href="#SpringMVC的优点" class="headerlink" title="SpringMVC的优点"></a>SpringMVC的优点</h4><blockquote><ul><li><p><strong>清晰的角色划分。</strong>SpringMVC在Model，View，Controller方面提供了非常清晰的角色划分，每个角色都可以由一个专门的对象来实现。前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。真正做到了各司其职，各负其责。</p></li><li><p><strong>分层设计。</strong>实现了业务系统各个组件之间的解耦，有利于业务系统的可拓展性，可维护性。</p></li><li><p><strong>灵活的配置功能。</strong>可以把类当作Bean通过XML进行配置。</p></li><li><p><strong>有利于系统的并行开发，提高开发效率。</strong>由于按层把系统分开，所以能够更好的实现开发中的分工，网页设计人员可以进行视图层JSP的开发，业务开发人员则可以进行业务层开发，其他人员则可以进行控制层的开发。</p></li><li><p><strong>可以支持各种视图技术，而不仅仅局限于JSP。</strong>SpringMVC不会强制开发者使用JSP，可以根据项目需求使用Velocity，FreeMarker等技术。</p></li><li><p><strong>支持各种请求资源的映射策略。</strong>并且支持RESTful编程风格的请求。</p></li><li><p><strong>灵活性强，可以与其他Spring的其他框架无缝集成(IOC，AOP)。</strong>因为与SpringIOC容器做到了无缝集成，这意味着，Spring提供的任何特性，在SpringMVC中都可以使用。</p></li><li><p><strong>支持国际化。可以根据用户区域显示多国语言。</strong></p></li><li><p><strong>提供了一个前端控制器DispatcherServlet，使开发人员无需额外开发控制器对象。</strong></p></li></ul></blockquote></li></ul><hr><ul><li><h4 id="SpringMVC的原理-x2F-工作流程"><a href="#SpringMVC的原理-x2F-工作流程" class="headerlink" title="SpringMVC的原理&#x2F;工作流程"></a>SpringMVC的原理&#x2F;工作流程</h4><blockquote><p>在没有使用SpringMVC之前，我们都是使用Servlet进行Web开发，但是使用Servlet在请求参数，数据共享，页面跳转等操作相对复杂。Servlet是Java进行Web开发的标准，<strong>既然SpringMVC是对Servlet的封装，那么很显然SpringMVC的底层就是Servlet。</strong></p><p><strong>SpringMVC工作流程：</strong></p><ol><li>用户发送请求至前端控制器<strong>DispatcherServlet。</strong></li><li><strong>DispatcherServlet</strong>收到请求后，调用<strong>HandlerMapping</strong>处理器映射器，请求获取<strong>Handler</strong>。</li><li>处理器映射器<strong>根据请求url</strong>找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给<strong>DispatcherServlet。</strong></li><li><strong>DispatcherServlet</strong>调用<strong>HandlerAdapter</strong>处理器适配器。</li><li><strong>HandlerAdapter</strong>经过适配调用具体的处理器。(<strong>Handler</strong>，也叫后端控制器)</li><li><strong>Handler</strong>执行完成返回<strong>ModelAndView</strong>。</li><li><strong>HandlerAdapter</strong>将<strong>Handler</strong>执行结果<strong>ModelAndView</strong>返回给<strong>DispatcherServlet。</strong></li><li><strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>传给<strong>ViewResolver</strong>视图解析器进行解析。</li><li><strong>ViewResolver</strong>解析后返回具体的<strong>View。</strong></li><li><strong>DispatcherServlet</strong>对<strong>View</strong>进行渲染视图(即将模型数据填充至视图中)。</li><li><strong>DispatcherServlet</strong>响应用户。</li></ol><p><strong>组件说明：</strong></p><ul><li><p><strong>DispatcherServlet：前端控制器。</strong>整个流程控制的中心，控制其他组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</p></li><li><p><strong>HandlerMapping：处理器映射器。</strong>根据用户请求找到对应具体的<strong>Handler</strong>处理器。</p></li><li><p><strong>Handler：处理器。</strong>业务处理的核心类，通常由开发者编写，描述具体的业务。</p></li><li><p><strong>HandlerAdapter：处理器适配器。</strong>通过它对处理器进行执行。</p></li><li><p><strong>ViewResolver：视图解析器。</strong>由框架提供，进行视图解析，将处理结果生成View视图。</p></li><li><p><strong>View：视图。</strong>最终产出结果，常用视图有JSP，HTML。</p></li></ul></blockquote></li></ul><hr><ul><li><h4 id="SpringMVC的作用"><a href="#SpringMVC的作用" class="headerlink" title="SpringMVC的作用"></a>SpringMVC的作用</h4><blockquote><p>在原先的Web开发中，用户发起请求后，由Tomcat对原始请求进行封装，封装成request对象，再封装响应对象response，最后根据用户的请求路径找到对应的Servlet，Servlet处理后将结果封装到response中，最后由Tomcat核心返回最终的响应体。</p><hr><p>我们可以发现，一旦项目中需要定义多个Servlet来处理不同模块的请求，而每个Servlet中都有一些共同的动作需要执行，我们往往需要花费一定的精力来写这些重复性代码。</p><p><strong>如何简化这些重复性代码，或者说将这些方法抽取出来呢？</strong></p><p>SpringMVC做的就是这件事，它将Servlet共有的重复性动作给抽取出来，开发者不再需要写Servlet，可以更加专注于业务逻辑的开发。即<strong>SpringMVC就是抽取了我们Web开发的共有部份，简化了开发。</strong></p></blockquote></li></ul><hr><ul><li><h4 id="SpringMVC如何与Ajax相互调用？"><a href="#SpringMVC如何与Ajax相互调用？" class="headerlink" title="SpringMVC如何与Ajax相互调用？"></a>SpringMVC如何与Ajax相互调用？</h4><blockquote><p><strong>通过Jackson框架把Java对象转换成js可以识别的json对象</strong></p><p>步骤：</p><ol><li><p>加入jackson.jar</p></li><li><p>配置json的映射</p></li><li><p>在接收Ajax方法里直接返回Object，List等，方法前要加@RequestBody注解</p></li></ol><p>PS. </p><p>什么是Ajax：Ajax是一种在无需重新加载整个网页的情况下，能够更新部份网页的技术。</p><p>Ajax的全称是Asynchronous JavaScript and XML，即<strong>异步JavaScript+XML。</strong></p><p>作用：与服务器进行数据交换，异步交互。</p></blockquote></li></ul><hr><ul><li><h4 id="SpringMVC怎样设定重定向和转发？"><a href="#SpringMVC怎样设定重定向和转发？" class="headerlink" title="SpringMVC怎样设定重定向和转发？"></a>SpringMVC怎样设定重定向和转发？</h4><blockquote><p>一般情况下，控制器方法返回字符串类型的值会被当成逻辑视图名处理。</p><p>如果返回的字符串中带 <strong>forward:</strong> 或 <strong>redirect:</strong> 前缀时，SpringMVC会对他们进行特殊处理，</p><p>将 **forward:  &#x2F;  redirect:**当成指示符其后的字符串作为URL来处理。</p><p>**转发：在返回值前面加”forward:”**，譬如”forward:user.do?name&#x3D;method4”</p><p>**重定向：在返回值前面加”redirect:”**，譬如”redirect:<a href="http://www.google.com&quot;/">http://www.google.com&quot;</a></p></blockquote></li></ul><hr><ul><li><h4 id="介绍一下WebApplicationContext"><a href="#介绍一下WebApplicationContext" class="headerlink" title="介绍一下WebApplicationContext"></a>介绍一下WebApplicationContext</h4><blockquote><p>WebApplicationContext是<strong>专门为Web设计的。它允许从相对于Web根目录的路径中装载配置文件完成初始化工作。</strong></p><p>WebApplicationContext继承了ApplicationContext并增加了一些Web应用必备的特有功能，它不同于一般的ApplicationContext，因为它能处理主题，并找到被关联的Servlet。</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是Spring</title>
      <link href="/2022/08/08/%E4%BB%80%E4%B9%88%E6%98%AFSpring/"/>
      <url>/2022/08/08/%E4%BB%80%E4%B9%88%E6%98%AFSpring/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="Spring相关知识"><a href="#Spring相关知识" class="headerlink" title="Spring相关知识"></a>Spring相关知识</h3></li></ul><blockquote><p>1.Spring是什么？</p><p>2.为什么要用Spring？</p><p>3.Spring有什么好处？</p><p>4.Spring中两大核心知识点是什么？</p></blockquote><ul><li><h4 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a><strong>什么是Spring</strong></h4></li></ul><blockquote><p>首先我们来Spring官方文档中对Spring的定义</p><p>What We Mean by “Spring”</p><p>The term “Spring” means different things in different contexts. <strong>It can be used to refer to the Spring Framework project itself, which is where it all started</strong>.Over time, other Spring projects have been built on top of the Spring Framework.<strong>Most often, when people say”Spring”, they mean the entire family of projects.</strong></p><p>简单翻译一下：”spring”在不同的环境中，代表的含义不同。它可以指代项目本身，spring这个词就是从这里开始的，随着时间的推移，其他的spring项目又基于Spring Framework产生。所以，大多数情况下，当人们谈到”Spring”的时候，他们的意思就是整个spring项目家族.</p><p>所以，通过官方文档，我们可以知道，从广义上理解，spring就是spring全家桶的核心基础，一款轻量级开源框架.</p><p>从狭义上理解，spring指的就是Spring Framework，特别是其中的核心概念和思想</p><p><strong>简言之，Spring就是一个框架，它能够统一管理各种Bean组件，由于其自身的高拓展性，方便与其他第三方软件集成，进而简化和加速软件开发过程</strong></p></blockquote><ul><li><h4 id="为什么要用Spring"><a href="#为什么要用Spring" class="headerlink" title="为什么要用Spring"></a><strong>为什么要用Spring</strong></h4></li></ul><blockquote><ol><li><p><strong>首先，是为了避免重复造轮子。</strong>因为Spring已经成为了Java开发的业界标准，经过多年的沉淀已经无数项目得实战检验，大家都是基于此框架进行开发，进而减少了没必要的交流。如果遇到问题也可以向同样使用此框架的刃进行交流。</p></li><li><p><strong>学习掌握Spring的理念。</strong>Spring作为当前最流行的框架之一，大部分企业都在使用，则必然有先进的理念所支撑，并且大家都已经认同Spring的理念，诸如IOC,AOP等。</p></li><li><p><strong>同时，Spring对很多异构技术提供了统一的编码模型。</strong>例如Spring Data，在开发环境中，当我们遇到多种数据库类型时(NoSQL，SQL)，Spirng Data为我们提供了一组的API接口，用统一的方式去做数据库持久化的开发。</p></li></ol></blockquote><ul><li><h4 id="Spring有什么好处"><a href="#Spring有什么好处" class="headerlink" title="Spring有什么好处"></a>Spring有什么好处</h4></li></ul><blockquote><ol><li><p><strong>简化配置 ：</strong>简化了SSM框架中对组件扫描，注释驱动等配置的编写，同时<strong>支持声明式事务处理</strong>，通过配置完成对事务的管理，无需手动编程。</p></li><li><p><strong>免费开源 ：</strong>Spring作为开源框架，为程序员提供了方便的同时，也为公司节省了成本。</p></li><li><p><strong>方便解耦，简化开发，并且兼容性强大：</strong>Spring框架简单来说就是一个大工厂，可以将所有对象的创建和依赖关系的维护都交给Spring容器进行管理，降低了组件之间的耦合性。</p></li><li><p><strong>AOP编程的支持：</strong>Spring的核心为<strong>IOC</strong>与<strong>AOP</strong>，它允许将一些通用的任务，<strong>安全，事务，日志</strong>等进行集中式处理，提高程序的复用性。</p></li><li><p><strong>方便对程序进行测试：</strong>Spring提供了对Junit4的支持，可以方便的使用注解对Spring程序继续测试</p></li><li><p><strong>方便集成各种优秀框架：</strong>Spring作为一款开源框架，并不排斥其他优秀的框架，其内部提供了对各种优秀框架的直接支持，如<strong>Hibernate、MyBatis</strong>。</p></li><li><p>1</p></li><li><p><strong>降低了Java EE中API的使用难度：</strong>Spring对Java开发中非常难用的一些API提供了封装，使其使用难度大大降低，如JDBC</p></li></ol></blockquote><ul><li><h4 id="Spring核心知识点：IOC-控制反转"><a href="#Spring核心知识点：IOC-控制反转" class="headerlink" title="Spring核心知识点：IOC  (控制反转)"></a>Spring核心知识点：IOC  (控制反转)</h4></li></ul><blockquote><ul><li><h4 id="Spring-IOC解决的是对象管理以及对象依赖问题"><a href="#Spring-IOC解决的是对象管理以及对象依赖问题" class="headerlink" title="Spring IOC解决的是对象管理以及对象依赖问题"></a><strong>Spring IOC解决的是对象管理以及对象依赖问题</strong></h4></li></ul><ol><li><p>IOC是Inversion Of Control的缩写，意为控制反转，<strong>即把原有自己掌控的事情交给别人来处理，旨在解决程序间的耦合问题。</strong></p></li><li><p><strong>IOC控制反转，它更多的指的是一种思想，或者设计模式。</strong>本来是由我们自己手动创建(new)对象，现在则把对象交给Spring的IOC容器来创建管理。所以可以把IOC容器理解为一个对象工厂，工厂管理这些对象的创建以及依赖关系，当我们需要使用对象的时候，则直接从工厂获取。</p><p>IOC的工作原理就是<strong>工厂模式+反射机制</strong></p></li><li><p><strong>控制反转是一种思想，而依赖注入是其实现方式。</strong>依赖注入，指的是对象无需自行创建或者管理它的依赖关系，依赖关系将自动注入到需要它的对象中。其中有4种常用的注入方式：<strong>set，构造器，静态工厂，实例工厂</strong>。通过<strong>注解</strong>或者<strong>xml配置文件</strong>进行实现</p></li></ol><ul><li><strong>为什么要用Spring IOC</strong></li></ul><ol><li><p>明明可以自己new出来对象，为什么要交给IOC容器进行管理？</p><p><strong>主要的好处在于可以将对象进行集中统一的管理，并且降低耦合度</strong></p><ul><li><p>理论上我们可以自己new对象，但是自己创建的对象需要我们自己去管理，可能需要实现很多复杂的条件才能满足需求。比如要实现对象增强，还得自己创建代理，但是通过Spring则可以使用AOP进行实现，因为AOP的底层是动态代理技术。</p></li><li><p>所以，在企业项目开发中，对象的创建不单单是new一下就完事了，还要考虑多个实现类，对象之间的依赖关系，单元测试，单例等复杂的问题，这就是我们为什么要用Spring IOC。</p></li></ul></li></ol></blockquote><ul><li><h4 id="Spring核心知识点：AOP-面向切面编程"><a href="#Spring核心知识点：AOP-面向切面编程" class="headerlink" title="Spring核心知识点：AOP(面向切面编程)"></a>Spring核心知识点：AOP(面向切面编程)</h4></li></ul><blockquote><ul><li><h4 id="Spring-AOP解决的是非业务代码抽取的问题"><a href="#Spring-AOP解决的是非业务代码抽取的问题" class="headerlink" title="Spring AOP解决的是非业务代码抽取的问题"></a>Spring AOP解决的是非业务代码抽取的问题</h4></li></ul><ol><li><p><strong>什么是AOP？</strong>AOP一般称为面向切面编程，其实就是在方法前后增加非业务代码，对其进行增强</p></li><li><p><strong>AOP底层的技术是动态代理</strong>，其在Spring内实现依赖的是BeanPostProcessor。当我们需要在方法上注入重复性的非业务代码时，就可以利用Spring AOP，将这些非业务代码抽取并封装为一个可重用的模块，这个模块就被称为<strong>切面(Aspect)，</strong>减少系统中的重复代码，降低模块间的耦合度，并提高系统的可维护性。其中真正被拦截并增强的方法，被称为<strong>切入点(Pointcut)。</strong></p></li><li><p>在Spring AOP种，切面的工作被称为<strong>通知(Advice)，</strong>其中有5种类型的通知：</p><ul><li><strong>前置通知（Before）：</strong>在目标方法被调用前被调用</li><li><strong>最终通知（After）：</strong>在目标方法执行后执行，不论目标方法是否正常执行完成</li><li><strong>后置通知（After-returning ）：</strong>在目标方法<strong>成功执行</strong>后执行，可以通过配置得到返回值</li><li><strong>异常通知（After-throwing）：</strong>在目标方法抛出异常时执行</li><li><strong>环绕通知（Around）：</strong>在目标方法执行前后都可以执行额外代码，包裹目标方法</li></ul></li><li><p>5种通知的常见使用场景</p><ul><li><strong>前置通知：</strong>记录日志（方法被调用）</li><li><strong>最终通知：</strong>记录日志（方法已调用，但不一定成功）</li><li><strong>后置通知：</strong>记录日志（方法已成功调用）</li><li><strong>异常通知：</strong>异常处理、控制事务</li><li><strong>环绕通知：</strong>控制事务、权限控制</li></ul></li></ol></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关注解</title>
      <link href="/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring系列相关注解"><a href="#Spring系列相关注解" class="headerlink" title="Spring系列相关注解"></a><strong>Spring系列相关注解</strong></h3><blockquote><p>为什么要使用SpringMVC全注解开发模式？</p><p>1.采用纯java代码，不再需要配置繁杂的xml文件,相对于xml更简洁方便</p><p>2.减少复杂配置文件的同时亦能享受到SpringIOC容器所提供的功能</p><p>3.享受面向对象带来的好处</p><p>4.开发过程中.java与.xml文件的不断切换会造成思维上的不连贯，降低开发效率</p><p>5.通过注解与JavaBean的结合，既减少了配置文件的体积，又增加了JavaBean的可读性与内聚性</p><p>6.Spring配置的流行趋势</p></blockquote><ul><li><blockquote><h4 id="Spring工厂相关注解"><a href="#Spring工厂相关注解" class="headerlink" title="Spring工厂相关注解"></a><strong>Spring工厂相关注解</strong></h4></blockquote></li></ul><ol><li><p><strong>@Configuration</strong>  : 表示当前的类是一个<strong>配置类</strong>，作用类似于  applicationContext.xml</p></li><li><p><strong>@Bean</strong>：<strong>将当前方法的返回值注册到 Spring 容器中</strong>，作用类似于配置文件里面的 Bean 标签</p></li><li><p><strong>@Resource（name&#x3D;“xx”）</strong>：按照名字去查找 bean</p></li><li><p><strong>@Component</strong>：<strong>把当前类装配进Spring容器</strong>，默认以类名作为id,类名首字母小写</p></li><li><p><strong>@Import：导入分配置类</strong></p></li></ol><ul><li><blockquote><h4 id="包扫描相关注解"><a href="#包扫描相关注解" class="headerlink" title="包扫描相关注解"></a><strong>包扫描相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Repository</strong>：一般加在 <strong>dao</strong> 层，同@Component</li><li><strong>@Service</strong>：一般加在 <strong>service</strong> 层，同@Component</li><li><strong>@Controller</strong>：一般加在 <strong>servlet &#x2F; Controller</strong> 层，同@Component</li><li><strong>@ComponentScan</strong>：<strong>表示组件扫描</strong>，默认会扫描所有的 @Repository、@Service、@Controller和@Component。其中，这个注解可以加 basePackages 属性：如果不指定，则默认扫描的是当前配置类下面所在的包的所有类；如果加了这个属性，则当前包，以及当前包下的子包，都会扫描</li><li><strong>@Autowired</strong>：自动装填，从Spring容器中寻找对象注入</li></ol><ul><li><blockquote><h4 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a><strong>AOP相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Aspect</strong>：表示当前类是一个切面</li><li><strong>@Before：</strong>前置通知(在原始切入点方法前运行)</li><li><strong>@AfterReturning：</strong>后置通知(方法正常执行完毕后运行)</li><li><strong>@AfterThrowing：</strong>异常通知(抛出异常后通知)</li><li><strong>@After：</strong>最终通知(不论方法是否正常运行都会最后执行)</li><li><strong>@Around：</strong>环绕通知(最简单强大，在原始切入点方法前后运行)</li></ol><ul><li><blockquote><h4 id="Prooerties文件相关注解"><a href="#Prooerties文件相关注解" class="headerlink" title="Prooerties文件相关注解"></a><strong>Prooerties文件相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@PropertySource（classpath: xx.properties）：</strong>引入Properties配置文件，这个注解的作用类似于配置文件中的 context:property-placeholder</li><li><strong>@Value（”${ xx.xxxx }”）：</strong>从Spring 容器中取回 peroperties 配置文件中对应的值，返回赋予给某个变量。<strong>用在变量上面，为普通类型属性注入内容</strong></li></ol><ul><li><blockquote><h4 id="事务相关注解"><a href="#事务相关注解" class="headerlink" title="事务相关注解"></a><strong>事务相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Transactional：</strong>开启事务，凡是加了这个注解的方法，都有事务，这个注解可以放在类上也可以放在方法上，如果放在类上，则表示该类下所有的方法都有事务。如果使用在方法上，则需要在Public方法上加此注解，否则不会生效</li><li><strong>@EnableTransactionManagement：</strong>开启事务注解，一般用在配置类&#x2F;启动类上</li></ol><ul><li><blockquote><h4 id="SpringMVC相关注解"><a href="#SpringMVC相关注解" class="headerlink" title="SpringMVC相关注解"></a><strong>SpringMVC相关注解</strong></h4></blockquote></li></ul><ol><li><p><strong>@RestController：</strong>这个注解是@ResponseBody 和 @Controller 注解的组合注解，意思是既是接口层，又不需要把返回值当作视图处理，是什么数据就直接返回什么数据</p></li><li><p><strong>@RequestMapping（”&#x2F;xxx”）：</strong>如果加在方法上，标记当前方法喂一个接口，里面的xxx就是请求的URL地址，<strong>统一当前类下面的所有方法的访问路径前缀</strong></p></li><li><p><strong>@RequestParam(value&#x3D;“xx”)：</strong>指定接收前端传过来的参数的别名，加了此注解的参数必须不能为null，不然会报错</p></li><li><p><strong>@PathVariable：</strong>映射URL中绑定的占位符，即<strong>接收请求路径中占位符的值</strong></p></li><li><p><strong>@JsonFormat（pattern&#x3D;“时间格式”）：</strong>进行时间格式化，加在实体类属性上面</p></li><li><p><strong>@RequestBody：</strong>主要用来接收前端传给后端的<strong>Json字符串中的数据</strong></p></li></ol><ul><li><blockquote><h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a><strong>全局异常处理</strong></h4></blockquote></li></ul><ol><li><strong>@ControllerAdvice：</strong>定义全局异常处理器，这是一个增强的处理器，其他处理器抛出异常，都会进入这里执行</li><li><strong>@ExceptionHandler（xx.class）：</strong>指定该方法要处理的异常，只有<strong>指定的异常被抛出</strong>时才会执行此方法</li></ol><ul><li><blockquote><h4 id="SpringBoot相关注解"><a href="#SpringBoot相关注解" class="headerlink" title="SpringBoot相关注解"></a><strong>SpringBoot相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@SpringBootApplication：</strong>说明当前类是一个配置类，类似于config的效果</li><li><strong>@EnableAutoConfiguration：</strong>开启自动化配置</li></ol><ul><li><blockquote><h4 id="整合Servlet"><a href="#整合Servlet" class="headerlink" title="整合Servlet"></a><strong>整合Servlet</strong></h4></blockquote></li></ul><ol><li><strong>@ServletComponentScan：</strong>扫描web基础组件，包括servlet,listener,filter</li></ol><ul><li><blockquote><h4 id="Mapper相关注释"><a href="#Mapper相关注释" class="headerlink" title="Mapper相关注释"></a><strong>Mapper相关注释</strong></h4></blockquote></li></ul><ol><li><strong>@Mapper：</strong>表示当前接口是一个mapper，<strong>用在mapper接口层的类上</strong>，每个mapper都需要此注释，如果不加批量扫描注解代替</li><li><strong>@MapperScan（“xxx”）：</strong>批量扫描xxx路径(全路径)下的所有mapper，此注解应加在SpringBoot启动类上</li></ol><ul><li><blockquote><h4 id="Swagger相关注解"><a href="#Swagger相关注解" class="headerlink" title="Swagger相关注解"></a><strong>Swagger相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Api(tags&#x3D;“xxx”)：</strong>主要加在Controller类上，表示对类的说明</li><li><strong>ApiModel：</strong>一般加在实体类中，用来描述实体类</li><li><strong>ApiModelProperty：</strong>描述实体类的属性，加在实体类中的属性上</li><li><strong>@ApiOperation：</strong>该注解可以描述这个接口的实际作用。用在方法上面</li><li><strong>@ApiImplicitParams：</strong>表示一组参数的说明</li><li><strong>@ApiImplicitParam：</strong>指定一个参数的各方面属性，用在@ApiImplicitParams注解中</li></ol><ul><li><blockquote><h4 id="Redis相关注解"><a href="#Redis相关注解" class="headerlink" title="Redis相关注解"></a>Redis相关注解</h4></blockquote></li></ul><ol><li><strong>@EnableCaching：</strong>开启redis缓存功能，此注解应加在SpringBoot启动类上</li><li><strong>@Cacheable：</strong>在方法执行前spring会先查看缓存中是否存有数据，如果有，则直接返回缓存数据，如果没有，调用方法并将方法返回值存入缓存</li><li><strong>@CachePut：</strong>将方法的返回值放到缓存中</li><li><strong>@CacheEvict：</strong>将一条或多条数据从缓存中删除</li></ol><ul><li><strong>Coming soon…</strong></li></ul><p><img src="/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/Develop\MyBlog\source_posts\Spring相关注解\category.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/27/hello-world/"/>
      <url>/2022/07/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p><strong>对搭建的博客完成大部分主题渲染，纪念一下</strong></p><p><img src="/2022/07/27/hello-world/Develop\MyBlog\themes\butterfly\source\img\tag.png"></p><p><strong>PS:博文就看心情更新吧</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
