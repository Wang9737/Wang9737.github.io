<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>什么是Spring</title>
      <link href="/2022/08/08/%E4%BB%80%E4%B9%88%E6%98%AFSpring/"/>
      <url>/2022/08/08/%E4%BB%80%E4%B9%88%E6%98%AFSpring/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="Spring相关知识"><a href="#Spring相关知识" class="headerlink" title="Spring相关知识"></a>Spring相关知识</h3></li></ul><blockquote><p>1.Spring是什么？</p><p>2.为什么要用Spring？</p><p>3.Spring有什么好处？</p><p>4.Spring中两大核心知识点是什么？</p></blockquote><ul><li><h4 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a><strong>什么是Spring</strong></h4></li></ul><blockquote><p>首先我们来Spring官方文档中对Spring的定义</p><p>What We Mean by “Spring”</p><p>The term “Spring” means different things in different contexts. <strong>It can be used to refer to the Spring Framework project itself, which is where it all started</strong>.Over time, other Spring projects have been built on top of the Spring Framework.<strong>Most often, when people say”Spring”, they mean the entire family of projects.</strong></p><p>简单翻译一下：”spring”在不同的环境中，代表的含义不同。它可以指代项目本身，spring这个词就是从这里开始的，随着时间的推移，其他的spring项目又基于Spring Framework产生。所以，大多数情况下，当人们谈到”Spring”的时候，他们的意思就是整个spring项目家族.</p><p>所以，通过官方文档，我们可以知道，从广义上理解，spring就是spring全家桶的核心基础，一款轻量级开源框架.</p><p>从狭义上理解，spring指的就是Spring Framework，特别是其中的核心概念和思想</p><p><strong>简言之，Spring就是一个框架，它能够统一管理各种Bean组件，由于其自身的高拓展性，方便与其他第三方软件集成，进而简化和加速软件开发过程</strong></p></blockquote><ul><li><h4 id="为什么要用Spring"><a href="#为什么要用Spring" class="headerlink" title="为什么要用Spring"></a><strong>为什么要用Spring</strong></h4></li></ul><blockquote><ol><li><p><strong>首先，是为了避免重复造轮子。</strong>因为Spring已经成为了Java开发的业界标准，经过多年的沉淀已经无数项目得实战检验，大家都是基于此框架进行开发，进而减少了没必要的交流。如果遇到问题也可以向同样使用此框架的刃进行交流。</p></li><li><p><strong>学习掌握Spring的理念。</strong>Spring作为当前最流行的框架之一，大部分企业都在使用，则必然有先进的理念所支撑，并且大家都已经认同Spring的理念，诸如IOC,AOP等。</p></li><li><p><strong>同时，Spring对很多异构技术提供了统一的编码模型。</strong>例如Spring Data，在开发环境中，当我们遇到多种数据库类型时(NoSQL，SQL)，Spirng Data为我们提供了一组的API接口，用统一的方式去做数据库持久化的开发。</p></li></ol></blockquote><ul><li><h4 id="Spring有什么好处"><a href="#Spring有什么好处" class="headerlink" title="Spring有什么好处"></a>Spring有什么好处</h4></li></ul><blockquote><ol><li><p><strong>简化配置 ：</strong>简化了SSM框架中对组件扫描，注释驱动等配置的编写，同时<strong>支持声明式事务处理</strong>，通过配置完成对事务的管理，无需手动编程。</p></li><li><p><strong>免费开源 ：</strong>Spring作为开源框架，为程序员提供了方便的同时，也为公司节省了成本。</p></li><li><p><strong>方便解耦，简化开发，并且兼容性强大：</strong>Spring框架简单来说就是一个大工厂，可以将所有对象的创建和依赖关系的维护都交给Spring容器进行管理，降低了组件之间的耦合性。</p></li><li><p><strong>AOP编程的支持：</strong>Spring的核心为<strong>IOC</strong>与<strong>AOP</strong>，它允许将一些通用的任务，<strong>安全，事务，日志</strong>等进行集中式处理，提高程序的复用性。</p></li><li><p><strong>方便对程序进行测试：</strong>Spring提供了对Junit4的支持，可以方便的使用注解对Spring程序继续测试</p></li><li><p><strong>方便集成各种优秀框架：</strong>Spring作为一款开源框架，并不排斥其他优秀的框架，其内部提供了对各种优秀框架的直接支持，如<strong>Hibernate、MyBatis</strong>。</p></li><li><p>1</p></li><li><p><strong>降低了Java EE中API的使用难度：</strong>Spring对Java开发中非常南勇的一些API提供了封装，使其使用难度大大降低，如JDBC</p></li></ol></blockquote><ul><li><h4 id="Spring核心知识点：IOC-控制反转"><a href="#Spring核心知识点：IOC-控制反转" class="headerlink" title="Spring核心知识点：IOC  (控制反转)"></a>Spring核心知识点：IOC  (控制反转)</h4></li></ul><blockquote><ul><li><h5 id="Spring-IOC解决的是对象管理以及对象依赖问题"><a href="#Spring-IOC解决的是对象管理以及对象依赖问题" class="headerlink" title="Spring IOC解决的是对象管理以及对象依赖问题"></a><strong>Spring IOC解决的是对象管理以及对象依赖问题</strong></h5></li></ul><ol><li><p>IOC是Inversion Of Control的缩写，意为控制反转，<strong>即把原有自己掌控的事情交给别人来处理，旨在解决程序间的耦合问题。</strong></p></li><li><p><strong>IOC控制反转，它更多的指的是一种思想，或者设计模式。</strong>本来是由我们自己手动创建(new)对象，现在则把对象交给Spring的IOC容器来创建管理。所以可以把IOC容器理解为一个对象工厂，工厂管理这些对象的创建以及依赖关系，当我们需要使用对象的时候，则直接从工厂获取。</p><p>IOC的工作原理就是<strong>工厂模式+反射机制</strong></p></li><li><p><strong>控制反转是一种思想，而依赖注入是其实现方式。</strong>依赖注入，指的是对象无需自行创建或者管理它的依赖关系，依赖关系将自动注入到需要它的对象中。其中有4种常用的注入方式：<strong>set，构造器，静态工厂，实例工厂</strong>。通过<strong>注解</strong>或者<strong>xml配置文件</strong>进行实现</p></li></ol><ul><li><strong>为什么要用Spring IOC</strong></li></ul><ol><li><p>明明可以自己new出来对象，为什么要交给IOC容器进行管理？</p><p><strong>主要的好处在于可以将对象进行集中统一的管理，并且降低耦合度</strong></p><ul><li><p>理论上我们可以自己new对象，但是自己创建的对象需要我们自己去管理，可能需要实现很多复杂的条件才能满足需求。比如要实现对象增强，还得自己创建代理，但是通过Spring则可以使用AOP进行实现，因为AOP的底层是动态代理技术。</p></li><li><p>所以，在企业项目开发中，对象的创建不单单是new一下就完事了，还要考虑多个实现类，对象之间的依赖关系，单元测试，单例等复杂的问题，这就是我们为什么要用Spring IOC。</p></li></ul></li></ol></blockquote><ul><li><h4 id="Spring核心知识点：AOP-面向切面编程"><a href="#Spring核心知识点：AOP-面向切面编程" class="headerlink" title="Spring核心知识点：AOP(面向切面编程)"></a>Spring核心知识点：AOP(面向切面编程)</h4></li></ul><blockquote><ul><li><h5 id="Spring-AOP解决的是非业务代码抽取的问题"><a href="#Spring-AOP解决的是非业务代码抽取的问题" class="headerlink" title="Spring AOP解决的是非业务代码抽取的问题"></a>Spring AOP解决的是非业务代码抽取的问题</h5></li></ul><ol><li><p><strong>什么是AOP？</strong>AOP一般称为面向切面编程，其实就是在方法前后增加非业务代码，对其进行增强</p></li><li><p><strong>AOP底层的技术是动态代理</strong>，其在Spring内实现依赖的是BeanPostProcessor。当我们需要在方法上注入重复性的非业务代码时，就可以利用Spring AOP，将这些非业务代码抽取并封装为一个可重用的模块，这个模块就被称为**切面(Aspect)<strong>，减少系统中的重复代码，降低模块间的耦合度，并提高系统的可维护性。其中真正被拦截并增强的方法，被称为</strong>切入点(Pointcut)**。</p></li><li><p>在Spring AOP种，切面的工作被称为**通知(Advice)**，其中有5种类型的通知：</p><ul><li><strong>前置通知（Before）：</strong>在目标方法被调用前被调用</li><li><strong>最终通知（After）：</strong>在目标方法执行后执行，不论目标方法是否正常执行完成</li><li><strong>后置通知（After-returning ）：</strong>在目标方法<strong>成功执行</strong>后执行，可以通过配置得到返回值</li><li><strong>异常通知（After-throwing）：</strong>在目标方法抛出异常时执行</li><li><strong>环绕通知（Around）：</strong>在目标方法执行前后都可以执行额外代码，包裹目标方法</li></ul></li><li><p>5种通知的常见使用场景</p><ul><li><strong>前置通知：</strong>记录日志（方法被调用）</li><li><strong>最终通知：</strong>记录日志（方法已调用，但不一定成功）</li><li><strong>后置通知：</strong>记录日志（方法已成功调用）</li><li><strong>异常通知：</strong>异常处理、控制事务</li><li><strong>环绕通知：</strong>控制事务、权限控制</li></ul></li></ol></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关注解</title>
      <link href="/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring系列相关注解"><a href="#Spring系列相关注解" class="headerlink" title="Spring系列相关注解"></a><strong>Spring系列相关注解</strong></h3><blockquote><p>为什么要使用SpringMVC全注解开发模式？</p><p>1.采用纯java代码，不再需要配置繁杂的xml文件,相对于xml更简洁方便</p><p>2.减少复杂配置文件的同时亦能享受到SpringIOC容器所提供的功能</p><p>3.享受面向对象带来的好处</p><p>4.开发过程中.java与.xml文件的不断切换会造成思维上的不连贯，降低开发效率</p><p>5.通过注解与JavaBean的结合，既减少了配置文件的体积，又增加了JavaBean的可读性与内聚性</p><p>6.Spring配置的流行趋势</p></blockquote><ul><li><blockquote><h4 id="Spring工厂相关注解"><a href="#Spring工厂相关注解" class="headerlink" title="Spring工厂相关注解"></a><strong>Spring工厂相关注解</strong></h4></blockquote></li></ul><ol><li><p><strong>@Configuration</strong>  : 表示当前的类是一个<strong>配置类</strong>，作用类似于  applicationContext.xml</p></li><li><p><strong>@Bean</strong>：<strong>将当前方法的返回值注册到 Spring 容器中</strong>，作用类似于配置文件里面的 Bean 标签</p></li><li><p><strong>@Resource（name&#x3D;“xx”）</strong>：按照名字去查找 bean</p></li><li><p><strong>@Component</strong>：<strong>把当前类装配进Spring容器</strong>，默认以类名作为id,类名首字母小写</p></li><li><p><strong>@Import：导入分配置类</strong></p></li></ol><ul><li><blockquote><h4 id="包扫描相关注解"><a href="#包扫描相关注解" class="headerlink" title="包扫描相关注解"></a><strong>包扫描相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Repository</strong>：一般加在 <strong>dao</strong> 层，同@Component</li><li><strong>@Service</strong>：一般加在 <strong>service</strong> 层，同@Component</li><li><strong>@Controller</strong>：一般加在 <strong>servlet &#x2F; Controller</strong> 层，同@Component</li><li><strong>@ComponentScan</strong>：<strong>表示组件扫描</strong>，默认会扫描所有的 @Repository、@Service、@Controller和@Component。其中，这个注解可以加 basePackages 属性：如果不指定，则默认扫描的是当前配置类下面所在的包的所有类；如果加了这个属性，则当前包，以及当前包下的子包，都会扫描</li><li><strong>@Autowired</strong>：自动装填，从Spring容器中寻找对象注入</li></ol><ul><li><blockquote><h4 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a><strong>AOP相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Aspect</strong>：表示当前类是一个切面</li><li><strong>@Before：</strong>前置通知(在原始切入点方法前运行)</li><li><strong>@AfterReturning：</strong>后置通知(方法正常执行完毕后运行)</li><li><strong>@AfterThrowing：</strong>异常通知(抛出异常后通知)</li><li><strong>@After：</strong>最终通知(不论方法是否正常运行都会最后执行)</li><li><strong>@Around：</strong>环绕通知(最简单强大，在原始切入点方法前后运行)</li></ol><ul><li><blockquote><h4 id="Prooerties文件相关注解"><a href="#Prooerties文件相关注解" class="headerlink" title="Prooerties文件相关注解"></a><strong>Prooerties文件相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@PropertySource（classpath: xx.properties）：</strong>引入Properties配置文件，这个注解的作用类似于配置文件中的 context:property-placeholder</li><li><strong>@Value（”${ xx.xxxx }”）：</strong>从Spring 容器中取回 peroperties 配置文件中对应的值，返回赋予给某个变量。<strong>用在变量上面，为普通类型属性注入内容</strong></li></ol><ul><li><blockquote><h4 id="事务相关注解"><a href="#事务相关注解" class="headerlink" title="事务相关注解"></a><strong>事务相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Transactional：</strong>开启事务，凡是加了这个注解的方法，都有事务，这个注解可以放在类上也可以放在方法上，如果放在类上，则表示该类下所有的方法都有事务。如果使用在方法上，则需要在Public方法上加此注解，否则不会生效</li><li><strong>@EnableTransactionManagement：</strong>开启事务注解，一般用在配置类&#x2F;启动类上</li></ol><ul><li><blockquote><h4 id="SpringMVC相关注解"><a href="#SpringMVC相关注解" class="headerlink" title="SpringMVC相关注解"></a><strong>SpringMVC相关注解</strong></h4></blockquote></li></ul><ol><li><p><strong>@RestController：</strong>这个注解是@ResponseBody 和 @Controller 注解的组合注解，意思是既是接口层，又不需要把返回值当作视图处理，是什么数据就直接返回什么数据</p></li><li><p><strong>@RequestMapping（”&#x2F;xxx”）：</strong>如果加在方法上，标记当前方法喂一个接口，里面的xxx就是请求的URL地址，<strong>统一当前类下面的所有方法的访问路径前缀</strong></p></li><li><p><strong>@RequestParam(value&#x3D;“xx”)：</strong>指定接收前端传过来的参数的别名，加了此注解的参数必须不能为null，不然会报错</p></li><li><p><strong>@PathVariable：</strong>映射URL中绑定的占位符，即<strong>接收请求路径中占位符的值</strong></p></li><li><p><strong>@JsonFormat（pattern&#x3D;“时间格式”）：</strong>进行时间格式化，加在实体类属性上面</p></li><li><p><strong>@RequestBody：</strong>主要用来接收前端传给后端的<strong>Json字符串中的数据</strong></p></li></ol><ul><li><blockquote><h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a><strong>全局异常处理</strong></h4></blockquote></li></ul><ol><li><strong>@ControllerAdvice：</strong>定义全局异常处理器，这是一个增强的处理器，其他处理器抛出异常，都会进入这里执行</li><li><strong>@ExceptionHandler（xx.class）：</strong>指定该方法要处理的异常，只有<strong>指定的异常被抛出</strong>时才会执行此方法</li></ol><ul><li><blockquote><h4 id="SpringBoot相关注解"><a href="#SpringBoot相关注解" class="headerlink" title="SpringBoot相关注解"></a><strong>SpringBoot相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@SpringBootApplication：</strong>说明当前类是一个配置类，类似于config的效果</li><li><strong>@EnableAutoConfiguration：</strong>开启自动化配置</li></ol><ul><li><blockquote><h4 id="整合Servlet"><a href="#整合Servlet" class="headerlink" title="整合Servlet"></a><strong>整合Servlet</strong></h4></blockquote></li></ul><ol><li><strong>@ServletComponentScan：</strong>扫描web基础组件，包括servlet,listener,filter</li></ol><ul><li><blockquote><h4 id="Mapper相关注释"><a href="#Mapper相关注释" class="headerlink" title="Mapper相关注释"></a><strong>Mapper相关注释</strong></h4></blockquote></li></ul><ol><li><strong>@Mapper：</strong>表示当前接口是一个mapper，<strong>用在mapper接口层的类上</strong>，每个mapper都需要此注释，如果不加批量扫描注解代替</li><li><strong>@MapperScan（“xxx”）：</strong>批量扫描xxx路径(全路径)下的所有mapper，此注解应加在SpringBoot启动类上</li></ol><ul><li><blockquote><h4 id="Swagger相关注解"><a href="#Swagger相关注解" class="headerlink" title="Swagger相关注解"></a><strong>Swagger相关注解</strong></h4></blockquote></li></ul><ol><li><strong>@Api(tags&#x3D;“xxx”)：</strong>主要加在Controller类上，表示对类的说明</li><li><strong>ApiModel：</strong>一般加在实体类中，用来描述实体类</li><li><strong>ApiModelProperty：</strong>描述实体类的属性，加在实体类中的属性上</li><li><strong>@ApiOperation：</strong>该注解可以描述这个接口的实际作用。用在方法上面</li><li><strong>@ApiImplicitParams：</strong>表示一组参数的说明</li><li><strong>@ApiImplicitParam：</strong>指定一个参数的各方面属性，用在@ApiImplicitParams注解中</li></ol><ul><li><blockquote><h4 id="Redis相关注解"><a href="#Redis相关注解" class="headerlink" title="Redis相关注解"></a>Redis相关注解</h4></blockquote></li></ul><ol><li><strong>@EnableCaching：</strong>开启redis缓存功能，此注解应加在SpringBoot启动类上</li><li><strong>@Cacheable：</strong>在方法执行前spring会先查看缓存中是否存有数据，如果有，则直接返回缓存数据，如果没有，调用方法并将方法返回值存入缓存</li><li><strong>@CachePut：</strong>将方法的返回值放到缓存中</li><li><strong>@CacheEvict：</strong>将一条或多条数据从缓存中删除</li></ol><ul><li><strong>Coming soon…</strong></li></ul><p><img src="/2022/07/29/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/Develop\MyBlog\source_posts\Spring相关注解\category.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/27/hello-world/"/>
      <url>/2022/07/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p><strong>对搭建的博客完成大部分主题渲染，纪念一下</strong></p><p><img src="/2022/07/27/hello-world/Develop\MyBlog\themes\butterfly\source\img\tag.png"></p><p><strong>PS:博文就看心情更新吧</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
